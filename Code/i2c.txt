; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\ --list_dir=.\ --depend=.\obj\i2c.d --apcs=interwork --diag_suppress=9931 -IC:\Keil_v5\ARM\INC\Phillips -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -DDEVELOPMENT --omf_browse=.\obj\i2c.crf i2c.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C0MasterHandler PROC
;;;62     
;;;63     static void I2C0MasterHandler(void) __irq 
000000  e92d13ff          PUSH     {r0-r9,r12}
;;;64     {
;;;65       BYTE StatValue;
;;;66     
;;;67       /* this handler deals with master read and master write only */
;;;68     	
;;;69     	////
;;;70     	// the document referenced below is UM10211 
;;;71     	// LPC2366-UsersManual
;;;72     	// I2C section, pages526 & 527
;;;73     	/////
;;;74       StatValue = I20STAT;
000004  e59f149c          LDR      r1,|L1.1192|
000008  e5910004          LDR      r0,[r1,#4]
;;;75     	lastState = StatValue;
00000c  e59f2498          LDR      r2,|L1.1196|
000010  e20000ff          AND      r0,r0,#0xff           ;74
000014  e5c20009          STRB     r0,[r2,#9]  ; lastState
;;;76       IENABLE;				/* handles nested interrupt */	
000018  e14f5000          MRS      r5,SPSR
00001c  e582500c          STR      r5,[r2,#0xc]  ; sysreg
000020  e321f01f          MSR      CPSR_c,#0x1f
;;;77     	/////
;;;78     	// Enable these to get spew of state transition
;;;79     	/////
;;;80     	//U0THR='0'+((StatValue&0xF0)>>4);
;;;81     	//U0THR='0'+(StatValue&0x0f);
;;;82       switch ( StatValue )
;;;83       {
;;;84     		case 0x08:
;;;85     			I2CStarted = TRUE;
;;;86     			/////
;;;87     			// A start condition has been issued
;;;88     			// Load SLA+W
;;;89     			// Clear STA
;;;90     			/////
;;;91     			I20DAT = I2CSLA_W;
;;;92     
;;;93     			/////
;;;94     			// clear STA (start condition)
;;;95     			// clear SIC (interrupt)
;;;96     			/////
;;;97     			I20CONCLR = (I2CONCLR_SIC | I2CONCLR_STAC);
;;;98     
;;;99     			break;
;;;100    	
;;;101    		case 0x10:			/* A repeated started is issued */
;;;102    			/////
;;;103    			// A repeated start has been issued
;;;104    			// the document says that:
;;;105    			// 	to remain in MST/XMIT Mode, load SLA+W
;;;106    			// 	to change to MST/REC mode, load SLA+R
;;;107    			//
;;;108    			// We will switch to MST/REC mode if SLA+R is available
;;;109    			// otherwise, we will stop the bus and complete the transfer
;;;110    			/////
;;;111    			if(0 != I2CSLA_R)
;;;112    			{
;;;113    				I20DAT = I2CSLA_R;
;;;114    			}
;;;115    			else
;;;116    			{
;;;117    				I2CStarted = FALSE;
;;;118    				I2CComplete = TRUE;
;;;119    				I2CFailed = TRUE;
;;;120    				I20CONSET = I2CONSET_STO;      /* Set Stop flag */
;;;121    			}
;;;122    		
;;;123    		
;;;124    			/////
;;;125    			// clear STA (start condition)
;;;126    			// clear SIC (interrupt)
;;;127    			/////
;;;128    			I20CONCLR = (I2CONCLR_SIC | I2CONCLR_STAC);
;;;129    			break;
;;;130    	
;;;131    		case 0x18:			/* Regardless, it's an ACK */
;;;132    			/////
;;;133    			// SLA+W has been transmitted
;;;134    			// ACK has been received
;;;135    			/////
;;;136    			/////
;;;137    			// the documentation says:
;;;138    			// Load data byte
;;;139    			//      or
;;;140    			// Issue repeated start
;;;141    			//      or
;;;142    			// Issue stop condition
;;;143    			//      or
;;;144    			// Issue stop condition follwed by a START condition 
;;;145    			/////
;;;146    			if ( WrIndex < I2CWriteLength )
;;;147    			{
;;;148    				/////
;;;149    				// more data to send, 
;;;150    				// we will load a data byte
;;;151    				/////
;;;152    				I20DAT = I2CWriteBuffer[WrIndex++];
000024  e59f7484          LDR      r7,|L1.1200|
000028  e3500030          CMP      r0,#0x30              ;82
00002c  e3a03001          MOV      r3,#1                 ;85
000030  e3a04010          MOV      r4,#0x10              ;120
;;;153    			}
;;;154    			else
;;;155    			{
;;;156    				if(0 < I2CReadLength)
;;;157    				{
;;;158    					/////
;;;159    					// we have data to read
;;;160    					// so issue a repeated start
;;;161    					////
;;;162    					I20CONSET = I2CONSET_STA;	/* Set Repeated-start flag */
000034  e3a08020          MOV      r8,#0x20
;;;163    				}
;;;164    				else
;;;165    				{
;;;166    					/////
;;;167    					// no more data to read or write
;;;168    					// so stop the bus
;;;169    					/////
;;;170    					I2CComplete = TRUE;
;;;171    					I20CONSET = I2CONSET_STO;      /* Set Stop flag */
;;;172    				}
;;;173    			}
;;;174    
;;;175    			/////
;;;176    			// Clear SIC (intterupt)
;;;177    			/////
;;;178    			I20CONCLR = I2CONCLR_SIC;
000038  e3a0c008          MOV      r12,#8
00003c  e3a06000          MOV      r6,#0
000040  0a00002e          BEQ      |L1.256|
000044  ca000010          BGT      |L1.140|
000048  e3500018          CMP      r0,#0x18              ;82
00004c  0a00002b          BEQ      |L1.256|
000050  ca000009          BGT      |L1.124|
000054  e3500000          CMP      r0,#0                 ;82
000058  0a00001a          BEQ      |L1.200|
00005c  e3500008          CMP      r0,#8                 ;82
000060  e3a07028          MOV      r7,#0x28              ;97
000064  05c23004          STRBEQ   r3,[r2,#4]            ;85  ; I2CStarted
000068  05d20007          LDRBEQ   r0,[r2,#7]            ;91  ; I2CSLA_W
00006c  0a000020          BEQ      |L1.244|
000070  e3500010          CMP      r0,#0x10              ;82
000074  0a000016          BEQ      |L1.212|
000078  ea000012          B        |L1.200|
                  |L1.124|
00007c  e3500020          CMP      r0,#0x20              ;82
000080  13500028          CMPNE    r0,#0x28              ;82
000084  1a00000f          BNE      |L1.200|
000088  ea00001c          B        |L1.256|
                  |L1.140|
00008c  e3500050          CMP      r0,#0x50              ;82
;;;179    			break;
;;;180    	
;;;181    		case 0x20:
;;;182    			/////
;;;183    			// SLA+W has been transmitted
;;;184    			// NOT ACK has been received
;;;185    			/////
;;;186    			/////
;;;187    			// the documentation says:
;;;188    			// Load data byte (ACK bit will be received)
;;;189    			//      or
;;;190    			// Issue repeated start
;;;191    			//      or
;;;192    			// Issue stop condition
;;;193    			//      or
;;;194    			// Issue stop condition follwed by a START condition
;;;195    			// 
;;;196    			/////
;;;197    			if ( WrIndex < I2CWriteLength )
;;;198    			{
;;;199    				/////
;;;200    				// more data to send, 
;;;201    				// we will load a data byte
;;;202    				/////
;;;203    				I20DAT = I2CWriteBuffer[WrIndex++];
;;;204    			}
;;;205    			else
;;;206    			{
;;;207    				if(0 < I2CReadLength)
;;;208    				{
;;;209    					/////
;;;210    					// we have data to read
;;;211    					// so issue a repeated start
;;;212    					////
;;;213    					I20CONSET = I2CONSET_STA;	/* Set Repeated-start flag */
;;;214    				}
;;;215    				else
;;;216    				{
;;;217    					/////
;;;218    					// no more data to read or write
;;;219    					// so stop the bus
;;;220    					/////
;;;221    					I2CComplete = TRUE;
;;;222    					I20CONSET = I2CONSET_STO;      /* Set Stop flag */
;;;223    				}	
;;;224    			}
;;;225    	
;;;226    			/////
;;;227    			// Clear SIC (intterupt)
;;;228    			/////
;;;229    			I20CONCLR = I2CONCLR_SIC;
;;;230    			break;
;;;231    		
;;;232    		case 0x28:	/* Data byte has been transmitted, regardless ACK or NACK */
;;;233    		case 0x30:
;;;234    			/////
;;;235    			// Data byte has been transmitted
;;;236    			// Ack has been received (0x28)
;;;237    			// Not Ack has been received (0x30)
;;;238    			/////
;;;239    			/////
;;;240    			// the documentation says:
;;;241    			// Load data byte
;;;242    			//      or
;;;243    			// Issue repeated start
;;;244    			//      or
;;;245    			// Issue stop condition
;;;246    			//      or
;;;247    			// Issue stop condition follwed by a START condition
;;;248    			// 
;;;249    			/////
;;;250    			if ( WrIndex < I2CWriteLength )
;;;251    			{
;;;252    				/////
;;;253    				// data available to send, so load data byte
;;;254    				/////
;;;255    				I20DAT = I2CWriteBuffer[WrIndex++];
;;;256    			}
;;;257    			else
;;;258    			{
;;;259    				/////
;;;260    				// no more write data available
;;;261    				/////
;;;262    				if ( I2CReadLength != 0 )
;;;263    				{
;;;264    					/////
;;;265    					// data to read, so issue repeated start
;;;266    					/////
;;;267    					I20CONSET = I2CONSET_STA;	/* Set Repeated-start flag */
;;;268    				}
;;;269    				else
;;;270    				{
;;;271    					/////
;;;272    					// no data to read, 
;;;273    					// so stop the bus and complete the transfer
;;;274    					/////
;;;275    					I2CComplete = TRUE;
;;;276    					I20CONSET = I2CONSET_STO;      /* Set Stop flag */
;;;277    				}
;;;278    			}
;;;279    			/////
;;;280    			// clear the interrupt
;;;281    			/////
;;;282    			I20CONCLR = I2CONCLR_SIC;
;;;283    			break;
;;;284    	
;;;285    		case 0x40:
;;;286    			/////
;;;287    			// SLA+R has been  transmitted
;;;288    			// ACK has been received
;;;289    			/////
;;;290    			/////
;;;291    			// the documentation says:
;;;292    			// Data byte will be received, Ack bit will be returned (AA)
;;;293    			//      or
;;;294    			// Data byte will be received, Not Ack bit will be returned (~AA)
;;;295    			//      or
;;;296    			// Issue stop condition
;;;297    			//      or
;;;298    			// Issue stop condition follwed by a START condition
;;;299    			/////	
;;;300    			if(1 < I2CReadLength)
;;;301    			{
;;;302    				/////
;;;303    				// more than 1 byte to receive
;;;304    				// so issue ACK when the next byte is received
;;;305    				/////
;;;306    				I20CONSET = I2CONSET_AA;
000090  e3a07004          MOV      r7,#4
000094  0a000036          BEQ      |L1.372|
000098  aa000006          BGE      |L1.184|
00009c  e3500038          CMP      r0,#0x38              ;82
;;;307    			}
;;;308    			else
;;;309    			{
;;;310    				/////
;;;311    				// only 1 byte to receive
;;;312    				// so issue NOT ACK when the next byte is received
;;;313    				/////
;;;314    				I20CONCLR = I2CONSET_AA;
;;;315    			}
;;;316    			/////
;;;317    			// clear the interrupt
;;;318    			/////
;;;319    			I20CONCLR = I2CONCLR_SIC;
;;;320    			break;
;;;321    			
;;;322    		case 0x48:
;;;323    			/////
;;;324    			// SLA+R has been transmitted
;;;325    			// NOT ACK has been received
;;;326    			/////
;;;327    			/////
;;;328    			// the documentation says:
;;;329    			// Repeated start condition will be transmitted
;;;330    			//      or
;;;331    			// Issue stop condition
;;;332    			//      or
;;;333    			// Issue stop condition follwed by a START condition
;;;334    			/////	
;;;335    			I2CComplete = TRUE;
;;;336    			I2CFailed = TRUE;
;;;337    		
;;;338    			/////
;;;339    			// issue the stop flag
;;;340    			/////
;;;341    			I20CONSET = I2CONSET_STO;
;;;342    	
;;;343    			/////
;;;344    			// clear the interrupt
;;;345    			/////
;;;346    			I20CONCLR = I2CONCLR_SIC;
;;;347    			break;	
;;;348    		case 0x50:
;;;349    		case 0x58:
;;;350    			/////
;;;351    			// data byte has been transmitted
;;;352    			// ACK has been received (0x50)
;;;353    			// NOT ACK has been received (0x58)
;;;354    			/////
;;;355    			/////
;;;356    			// the documentation says:
;;;357    			// Data byte will be received, Ack bit will be returned (AA)
;;;358    			//      or
;;;359    			// Data byte will be received, Not Ack bit will be returned (~AA)
;;;360    			//      or
;;;361    			// Issue stop condition
;;;362    			//      or
;;;363    			// Issue stop condition follwed by a START condition
;;;364    			/////	
;;;365    			I2CReadBuffer[RdIndex++] = I20DAT;
;;;366    			if(RdIndex >= I2CReadLength-1)
;;;367    			{
;;;368    				/////
;;;369    				// only one more byte to recieve
;;;370    				// so issue NOT ACK when we read the next byte
;;;371    				/////
;;;372    				I20CONCLR = I2CONSET_AA;
;;;373    				if(RdIndex >= I2CReadLength)
;;;374    				{
;;;375    					/////
;;;376    					// no more data to receive
;;;377    					// set the stop flag
;;;378    					/////
;;;379    					I2CComplete = TRUE;
;;;380    					I20CONSET = I2CONSET_STO;
;;;381    				}
;;;382    			}
;;;383    
;;;384    			I20CONCLR = I2CONCLR_SIC;
;;;385    			break;
;;;386    	
;;;387    
;;;388    	
;;;389    		case 0x38:
;;;390    			/////
;;;391    			// Arbitration lost in NOT Ack bit
;;;392    			/////
;;;393    			/////
;;;394    			// the documentation says:
;;;395    			// I2C bus will be released; the I2C block will enter a slave mode
;;;396    			//      or
;;;397    			// A start condition will be transmitted when the bus becomes free
;;;398    			/////	
;;;399    			//U0THR='A';
;;;400    			I2CComplete = TRUE;
0000a0  05c23005          STRBEQ   r3,[r2,#5]  ; I2CComplete
;;;401    			I2CFailed = TRUE;
0000a4  05c23006          STRBEQ   r3,[r2,#6]  ; I2CFailed
0000a8  0a000021          BEQ      |L1.308|
0000ac  e3500040          CMP      r0,#0x40              ;82
0000b0  0a00002a          BEQ      |L1.352|
0000b4  ea000003          B        |L1.200|
                  |L1.184|
0000b8  e3500058          CMP      r0,#0x58              ;82
0000bc  0a00002c          BEQ      |L1.372|
0000c0  e35000f8          CMP      r0,#0xf8              ;82
0000c4  0a00001a          BEQ      |L1.308|
                  |L1.200|
0000c8  e5c23005          STRB     r3,[r2,#5]            ;335  ; I2CComplete
0000cc  e5c23006          STRB     r3,[r2,#6]            ;336  ; I2CFailed
0000d0  ea000016          B        |L1.304|
                  |L1.212|
0000d4  e5d20008          LDRB     r0,[r2,#8]            ;111  ; I2CSLA_R
0000d8  e3500000          CMP      r0,#0                 ;111
0000dc  15d20008          LDRBNE   r0,[r2,#8]            ;113  ; I2CSLA_R
0000e0  05c26004          STRBEQ   r6,[r2,#4]            ;117  ; I2CStarted
0000e4  05c23005          STRBEQ   r3,[r2,#5]            ;118  ; I2CComplete
0000e8  05c23006          STRBEQ   r3,[r2,#6]            ;119  ; I2CFailed
0000ec  05814000          STREQ    r4,[r1,#0]            ;120
0000f0  0a000000          BEQ      |L1.248|
                  |L1.244|
0000f4  e5810008          STR      r0,[r1,#8]            ;91
                  |L1.248|
0000f8  e5817018          STR      r7,[r1,#0x18]         ;128
0000fc  ea00000d          B        |L1.312|
                  |L1.256|
000100  e5d20001          LDRB     r0,[r2,#1]            ;146  ; WrIndex
000104  e5d29003          LDRB     r9,[r2,#3]            ;146  ; I2CWriteLength
000108  e1500009          CMP      r0,r9                 ;146
00010c  2a00000e          BCS      |L1.332|
000110  e5d20001          LDRB     r0,[r2,#1]            ;255  ; WrIndex
000114  e0873000          ADD      r3,r7,r0              ;255
000118  e2800001          ADD      r0,r0,#1              ;255
00011c  e5c20001          STRB     r0,[r2,#1]            ;255  ; WrIndex
000120  e5d30000          LDRB     r0,[r3,#0]            ;255
000124  e5810008          STR      r0,[r1,#8]            ;255
000128  ea000001          B        |L1.308|
                  |L1.300|
00012c  e5c23005          STRB     r3,[r2,#5]            ;170  ; I2CComplete
                  |L1.304|
;;;402    			I20CONCLR = I2CONCLR_SIC;
;;;403    			//#if DEBUG
;;;404    			//printf("ARBITRATION LOST!!!!\n\r");	
;;;405    			//#endif
;;;406    			break;
;;;407    		case 0x00:
;;;408    			/////
;;;409    			// bus error
;;;410    			// set the stop flag to reset the I2C bus
;;;411    			// clear the interrupt
;;;412    			/////
;;;413    			//U0THR='B';
;;;414    			I2CComplete = TRUE;
;;;415    			I2CFailed = TRUE;
;;;416    			I20CONSET = I2CONSET_STO;
;;;417    			I20CONCLR = I2CONCLR_SIC;
;;;418    			break;
;;;419    		case 0xF8:
;;;420    			/////
;;;421    			// no relavent information
;;;422    			// this occurs between other states
;;;423    			// and when the I2C block is not involved
;;;424    			// in a serial transfer
;;;425    			/////
;;;426    			/////
;;;427    			// if we are here, the interrupt flag is set
;;;428    			// so clear it anyway
;;;429    			/////
;;;430    			I20CONCLR = I2CONCLR_SIC;
;;;431    			break;
;;;432    		default:
;;;433    			//U0THR='O';
;;;434    			I2CComplete = TRUE;
;;;435    			I2CFailed = TRUE;
;;;436    			I20CONSET = I2CONSET_STO;
000130  e5814000          STR      r4,[r1,#0]
                  |L1.308|
000134  e581c018          STR      r12,[r1,#0x18]        ;178
                  |L1.312|
;;;437    			/////
;;;438    			// clear the interrupt
;;;439    			/////
;;;440    			I20CONCLR = I2CONCLR_SIC;	
;;;441    			break;
;;;442      }
;;;443      IDISABLE;
000138  e321f092          MSR      CPSR_c,#0x92
00013c  e16ff005          MSR      SPSR_cxsf,r5
;;;444      VICVectAddr = 0;		/* Acknowledge Interrupt */
000140  e5066100          STR      r6,[r6,#-0x100]
;;;445    }
000144  e8bd13ff          POP      {r0-r9,r12}
000148  e25ef004          SUBS     pc,lr,#4
                  |L1.332|
00014c  e5d20002          LDRB     r0,[r2,#2]            ;262  ; I2CReadLength
000150  e3500000          CMP      r0,#0                 ;262
000154  15818000          STRNE    r8,[r1,#0]            ;267
000158  1afffff5          BNE      |L1.308|
00015c  eafffff2          B        |L1.300|
                  |L1.352|
000160  e5d20002          LDRB     r0,[r2,#2]            ;300  ; I2CReadLength
000164  e3500001          CMP      r0,#1                 ;300
000168  85817000          STRHI    r7,[r1,#0]            ;306
00016c  95817018          STRLS    r7,[r1,#0x18]         ;314
000170  eaffffef          B        |L1.308|
                  |L1.372|
000174  e5918008          LDR      r8,[r1,#8]            ;365
000178  e5d20000          LDRB     r0,[r2,#0]            ;365  ; RdIndex
00017c  e59f9330          LDR      r9,|L1.1204|
000180  e0899000          ADD      r9,r9,r0              ;365
000184  e2800001          ADD      r0,r0,#1              ;365
000188  e5c20000          STRB     r0,[r2,#0]            ;365  ; RdIndex
00018c  e5c98000          STRB     r8,[r9,#0]            ;365
000190  e5d20000          LDRB     r0,[r2,#0]            ;366  ; RdIndex
000194  e5d28002          LDRB     r8,[r2,#2]            ;366  ; I2CReadLength
000198  e2488001          SUB      r8,r8,#1              ;366
00019c  e1500008          CMP      r0,r8                 ;366
0001a0  baffffe3          BLT      |L1.308|
0001a4  e5817018          STR      r7,[r1,#0x18]         ;372
0001a8  e5d20000          LDRB     r0,[r2,#0]            ;373  ; RdIndex
0001ac  e5d27002          LDRB     r7,[r2,#2]            ;373  ; I2CReadLength
0001b0  e1500007          CMP      r0,r7                 ;373
0001b4  3affffde          BCC      |L1.308|
0001b8  eaffffdb          B        |L1.300|
;;;446    /*****************************************************************************
                          ENDP

                  I2CSetBaud PROC
;;;524    
;;;525    void I2CSetBaud(BOOL speed)
0001bc  e3500001          CMP      r0,#1
;;;526    {
;;;527    	if(speed == TRUE)
;;;528    	{		
;;;529    		I20SCLL   = I2SCLL_SCLL;
0001c0  e59f12e0          LDR      r1,|L1.1192|
0001c4  03a0005a          MOVEQ    r0,#0x5a
;;;530    		I20SCLH   = I2SCLH_SCLH;
;;;531    	}
;;;532    	else
;;;533    	{	
;;;534    		I20SCLL   = I2SCLL_SCLL_SLOW;
0001c8  13a0000a          MOVNE    r0,#0xa
0001cc  e5810014          STR      r0,[r1,#0x14]         ;529
0001d0  e5810010          STR      r0,[r1,#0x10]         ;530
;;;535    		I20SCLH   = I2SCLH_SCLH_SLOW;
;;;536    	}
;;;537    }
0001d4  e12fff1e          BX       lr
;;;538    
                          ENDP

                  I2CInitialize PROC
;;;598    
;;;599    void I2CInitialize()
0001d8  e92d4010          PUSH     {r4,lr}
;;;600    {
;;;601    	initTimer(&hangTimer);	
0001dc  e59f02d4          LDR      r0,|L1.1208|
0001e0  ebfffffe          BL       initTimer
;;;602    	startTimer(&hangTimer, I2C_HANGUP_TIMER_MS);
0001e4  e59f02cc          LDR      r0,|L1.1208|
0001e8  e3a01064          MOV      r1,#0x64
0001ec  ebfffffe          BL       startTimer
;;;603    
;;;604    	I2CReadLength = 0;
0001f0  e59f02b4          LDR      r0,|L1.1196|
0001f4  e3a01000          MOV      r1,#0
0001f8  e5c01002          STRB     r1,[r0,#2]  ; I2CReadLength
;;;605    	I2CWriteLength = 0;
0001fc  e5c01003          STRB     r1,[r0,#3]  ; I2CWriteLength
;;;606    	
;;;607    	// initialize the I2C hardware
;;;608    	I2CHWInit( I2CMASTER );
000200  e8bd4010          POP      {r4,lr}
000204  e3a00001          MOV      r0,#1
000208  eafffffe          B        I2CHWInit
;;;609    	
;;;610    }
;;;611    
                          ENDP

                  i2cDataTransaction PROC
;;;612    
;;;613    BOOL i2cDataTransaction(BYTE *writeData, int nWriteLength, int nReadLength, BYTE nSLA_W, BYTE subAddress, BYTE *theData)
00020c  e92d47f0          PUSH     {r4-r10,lr}
;;;614    {    
000210  e1a08001          MOV      r8,r1
000214  e1a09000          MOV      r9,r0
;;;615        int i;
;;;616        
;;;617    	// start the lost transfer timer
;;;618    	startTimer(&hangTimer, I2C_HANGUP_TIMER_MS);	
000218  e59f0298          LDR      r0,|L1.1208|
00021c  e59d6024          LDR      r6,[sp,#0x24]
000220  e59da020          LDR      r10,[sp,#0x20]
000224  e1a07003          MOV      r7,r3                 ;614
000228  e1a05002          MOV      r5,r2                 ;614
00022c  e3a01064          MOV      r1,#0x64
000230  ebfffffe          BL       startTimer
;;;619    
;;;620    	// stop the bus
;;;621    	if(I2CStop() == FALSE)
000234  ebfffffe          BL       I2CStop
000238  e3500000          CMP      r0,#0
00023c  0a00002f          BEQ      |L1.768|
000240  e59f126c          LDR      r1,|L1.1204|
000244  e3a0c000          MOV      r12,#0
000248  e1a0000c          MOV      r0,r12
00024c  e2414010          SUB      r4,r1,#0x10
                  |L1.592|
000250  e7c1000c          STRB     r0,[r1,r12]
000254  e7c4000c          STRB     r0,[r4,r12]
000258  e28cc001          ADD      r12,r12,#1
00025c  e35c0010          CMP      r12,#0x10
;;;622    	{
;;;623    		return FALSE;
;;;624    	}
;;;625    
;;;626    	// clear the master buffer
;;;627    	I2CBufferClear();
;;;628    
;;;629    	I2CWriteBuffer[0] = subAddress;
000260  a5c4a000          STRBGE   r10,[r4,#0]  ; I2CWriteBuffer
;;;630        
;;;631        // first byte of write buffer is the device register # (or subAddress)
;;;632        for(i=0; i < nWriteLength; i++)
000264  a3a0c000          MOVGE    r12,#0
000268  bafffff8          BLT      |L1.592|
00026c  ea000003          B        |L1.640|
                  |L1.624|
;;;633        {
;;;634            I2CWriteBuffer[i+1] = writeData[i];
000270  e7d9100c          LDRB     r1,[r9,r12]
000274  e084200c          ADD      r2,r4,r12
000278  e5c21001          STRB     r1,[r2,#1]
00027c  e28cc001          ADD      r12,r12,#1
                  |L1.640|
000280  e15c0008          CMP      r12,r8                ;632
000284  bafffff9          BLT      |L1.624|
;;;635        }
;;;636    		
;;;637    	// grab SLA_W and SLA_R
;;;638    	// grab write and read lengths
;;;639    	I2CWriteLength = nWriteLength + 1;
000288  e59f421c          LDR      r4,|L1.1196|
00028c  e2881001          ADD      r1,r8,#1
000290  e5c41003          STRB     r1,[r4,#3]  ; I2CWriteLength
;;;640    	I2CReadLength = nReadLength;
000294  e5c45002          STRB     r5,[r4,#2]  ; I2CReadLength
;;;641    	I2CSLA_W = nSLA_W;
000298  e5c47007          STRB     r7,[r4,#7]  ; I2CSLA_W
;;;642    	I2CSLA_R = nSLA_W + 1;
00029c  e2871001          ADD      r1,r7,#1
0002a0  e5c41008          STRB     r1,[r4,#8]  ; I2CSLA_R
;;;643       		
;;;644    	// reset the indexes
;;;645    	// and start the transfer
;;;646    	RdIndex = 0;
0002a4  e5c40000          STRB     r0,[r4,#0]  ; RdIndex
;;;647    	WrIndex = 0;
0002a8  e5c40001          STRB     r0,[r4,#1]  ; WrIndex
0002ac  e3a01000          MOV      r1,#0
0002b0  e5c40004          STRB     r0,[r4,#4]  ; I2CStarted
0002b4  e5c40005          STRB     r0,[r4,#5]  ; I2CComplete
0002b8  e5c40006          STRB     r0,[r4,#6]  ; I2CFailed
0002bc  e59f21e4          LDR      r2,|L1.1192|
0002c0  e3a00020          MOV      r0,#0x20
0002c4  e5820000          STR      r0,[r2,#0]
0002c8  e1e008c2          MVN      r0,r2,ASR #17
                  |L1.716|
0002cc  e5d42004          LDRB     r2,[r4,#4]  ; I2CStarted
0002d0  e3520000          CMP      r2,#0
0002d4  1a00000b          BNE      |L1.776|
0002d8  e1510000          CMP      r1,r0
0002dc  32811001          ADDCC    r1,r1,#1
0002e0  3afffff9          BCC      |L1.716|
;;;648    	if(I2CStart() == FALSE)
;;;649    	{
;;;650    		I2CStop();
0002e4  ebfffffe          BL       I2CStop
;;;651    		return FALSE;
0002e8  ea000003          B        |L1.764|
                  |L1.748|
;;;652    	}
;;;653    
;;;654    	while(I2CComplete == FALSE)
;;;655    	{
;;;656    		if(isTimerExpired(&hangTimer))
0002ec  e59f01c4          LDR      r0,|L1.1208|
0002f0  ebfffffe          BL       isTimerExpired
0002f4  e3500000          CMP      r0,#0
0002f8  0a000002          BEQ      |L1.776|
                  |L1.764|
;;;657    		{
;;;658    			return FALSE;
0002fc  e3a00000          MOV      r0,#0
                  |L1.768|
000300  e8bd47f0          POP      {r4-r10,lr}
;;;659    		}
;;;660    	}
;;;661        
;;;662    
;;;663    	if(nReadLength != 0)
;;;664    	{        
;;;665    		if(theData != 0)
;;;666    		{
;;;667    			memcpy(theData, I2CReadBuffer, RdIndex);
;;;668    		}
;;;669    	}
;;;670    	
;;;671    	return TRUE;
;;;672    }
000304  e12fff1e          BX       lr
                  |L1.776|
000308  e5d40005          LDRB     r0,[r4,#5]            ;654  ; I2CComplete
00030c  e3500000          CMP      r0,#0                 ;654
000310  0afffff5          BEQ      |L1.748|
000314  e3550000          CMP      r5,#0                 ;663
000318  13560000          CMPNE    r6,#0                 ;665
00031c  0a000003          BEQ      |L1.816|
000320  e5d42000          LDRB     r2,[r4,#0]            ;667  ; RdIndex
000324  e59f1188          LDR      r1,|L1.1204|
000328  e1a00006          MOV      r0,r6                 ;667
00032c  ebfffffe          BL       __aeabi_memcpy
                  |L1.816|
000330  e3a00001          MOV      r0,#1                 ;671
000334  eafffff1          B        |L1.768|
;;;673    
                          ENDP

                  i2cWriteByte PROC
;;;674    
;;;675    BOOL i2cWriteByte(BYTE address, BYTE subAddress, BYTE data)
000338  e92d4007          PUSH     {r0-r2,lr}
;;;676    {
00033c  e24dd010          SUB      sp,sp,#0x10
;;;677    	BOOL returnValue = FALSE;
;;;678    	BYTE dest;
;;;679    
;;;680    	returnValue = i2cDataTransaction(&data, 1, 0, address, subAddress, &dest);
000340  e28d2008          ADD      r2,sp,#8
000344  e88d0006          STM      sp,{r1,r2}
000348  e1a03000          MOV      r3,r0
00034c  e3a02000          MOV      r2,#0
000350  e3a01001          MOV      r1,#1
000354  e28d0018          ADD      r0,sp,#0x18
000358  ebfffffe          BL       i2cDataTransaction
00035c  e28dd01c          ADD      sp,sp,#0x1c
000360  e49de004          POP      {lr}
;;;681    
;;;682    	return returnValue;
;;;683    }
000364  e12fff1e          BX       lr
;;;684    
                          ENDP

                  i2cWriteBytes PROC
;;;685    BOOL i2cWriteBytes(BYTE address, BYTE subAddress, BYTE count, BYTE *data)
000368  e92d403e          PUSH     {r1-r5,lr}
;;;686    {
;;;687    	BOOL returnValue = FALSE;
;;;688    	BYTE dest;
;;;689    
;;;690    	returnValue = i2cDataTransaction(data, count, 0, address, subAddress, &dest);
00036c  e28dc008          ADD      r12,sp,#8
000370  e1a04003          MOV      r4,r3                 ;686
000374  e1a05002          MOV      r5,r2                 ;686
000378  e88d1002          STM      sp,{r1,r12}
00037c  e1a03000          MOV      r3,r0
000380  e3a02000          MOV      r2,#0
000384  e1a01005          MOV      r1,r5
000388  e1a00004          MOV      r0,r4
00038c  ebfffffe          BL       i2cDataTransaction
000390  e8bd403e          POP      {r1-r5,lr}
;;;691    
;;;692    	return returnValue;
;;;693    }
000394  e12fff1e          BX       lr
;;;694    
                          ENDP

                  i2cReadByte PROC
;;;695    BOOL i2cReadByte(BYTE address, BYTE subAddress, BYTE *dest)
000398  e92d401c          PUSH     {r2-r4,lr}
;;;696    {
;;;697    	BOOL returnValue = FALSE;
;;;698    
;;;699    	returnValue = i2cDataTransaction(0, 0, 1, address, subAddress, dest);
00039c  e88d0006          STM      sp,{r1,r2}
0003a0  e1a03000          MOV      r3,r0
0003a4  e3a01000          MOV      r1,#0
0003a8  e3a02001          MOV      r2,#1
0003ac  e1a00001          MOV      r0,r1
0003b0  ebfffffe          BL       i2cDataTransaction
0003b4  e8bd401c          POP      {r2-r4,lr}
;;;700    
;;;701    	return returnValue;
;;;702    }
0003b8  e12fff1e          BX       lr
;;;703    
                          ENDP

                  i2cReadBytes PROC
;;;704    BOOL i2cReadBytes(BYTE address, BYTE subAddress, BYTE count, BYTE *dest)
0003bc  e92d401c          PUSH     {r2-r4,lr}
;;;705    {  
0003c0  e88d000a          STM      sp,{r1,r3}
;;;706    	BOOL returnValue = FALSE;
;;;707    
;;;708    	returnValue = i2cDataTransaction(0, 0, count, address, subAddress, dest);
0003c4  e1a03000          MOV      r3,r0
0003c8  e3a01000          MOV      r1,#0
0003cc  e1a00001          MOV      r0,r1
0003d0  ebfffffe          BL       i2cDataTransaction
0003d4  e8bd401c          POP      {r2-r4,lr}
;;;709    
;;;710    	return returnValue;
;;;711    }
0003d8  e12fff1e          BX       lr
;;;712    
                          ENDP

                  I2CStop PROC
;;;455    *****************************************************************************/
;;;456    static unsigned long I2CStop( void )
0003dc  e59f00c4          LDR      r0,|L1.1192|
;;;457    {
;;;458      I20CONSET = I2CONSET_STO;      /* Set Stop flag */ 
0003e0  e3a01010          MOV      r1,#0x10
0003e4  e5801000          STR      r1,[r0,#0]
;;;459      I20CONCLR = I2CONCLR_SIC;      /* Clear SI flag */ 
0003e8  e3a01008          MOV      r1,#8
0003ec  e5801018          STR      r1,[r0,#0x18]
                  |L1.1008|
;;;460              
;;;461      /*--- Wait for STOP detected ---*/
;;;462      while( I20CONSET & I2CONSET_STO ); 
0003f0  e5901000          LDR      r1,[r0,#0]
0003f4  e3110010          TST      r1,#0x10
;;;463      return TRUE;
0003f8  03a00001          MOVEQ    r0,#1
0003fc  1afffffb          BNE      |L1.1008|
;;;464    }
000400  e12fff1e          BX       lr
;;;465    
                          ENDP

                  I2CHWInit PROC
;;;538    
;;;539    static unsigned long I2CHWInit( unsigned long I2cMode ) 
000404  e59f10b0          LDR      r1,|L1.1212|
;;;540    {
000408  e92d4010          PUSH     {r4,lr}
;;;541      PCONP   |= (1 << 19);
00040c  e59120c4          LDR      r2,[r1,#0xc4]
000410  e3822702          ORR      r2,r2,#0x80000
000414  e58120c4          STR      r2,[r1,#0xc4]
;;;542      PINSEL1 &= ~0x03C00000;
000418  e241281d          SUB      r2,r1,#0x1d0000
00041c  e5923004          LDR      r3,[r2,#4]
000420  e3c3350f          BIC      r3,r3,#0x3c00000
000424  e5823004          STR      r3,[r2,#4]
;;;543      PINSEL1 |= 0x01400000;	/* set PIO0.27 and PIO0.28 to I2C0 SDA and SCK */
000428  e5923004          LDR      r3,[r2,#4]
00042c  e3833505          ORR      r3,r3,#0x1400000
000430  e5823004          STR      r3,[r2,#4]
;;;544    							            /* function to 01 on both SDA and SCK. */
;;;545    	
;;;546    	// set up clocking
;;;547    	//PCLKSEL0 |= (CCLK_OVER_1 << PCLK_I2C0);
;;;548    	//PCLKSEL0 |= (CCLK_OVER_4 << PCLK_I2C0);
;;;549    	PCLKSEL0 |= (CCLK_OVER_8 << PCLK_I2C0);
000434  e59121a8          LDR      r2,[r1,#0x1a8]
000438  e3822903          ORR      r2,r2,#0xc000
00043c  e58121a8          STR      r2,[r1,#0x1a8]
;;;550    	PCONP |= (1 << PCI2C0);   	// i2c
000440  e59120c4          LDR      r2,[r1,#0xc4]
000444  e3822080          ORR      r2,r2,#0x80
000448  e58120c4          STR      r2,[r1,#0xc4]
;;;551    
;;;552      
;;;553      /*--- Clear flags ---*/
;;;554      I20CONCLR = I2CONCLR_AAC | I2CONCLR_SIC | I2CONCLR_STAC | I2CONCLR_I2ENC;    
00044c  e59f4054          LDR      r4,|L1.1192|
000450  e3a0106c          MOV      r1,#0x6c
000454  e5841018          STR      r1,[r4,#0x18]
;;;555    
;;;556      /*--- Reset registers ---*/
;;;557      I20SCLL   = I2SCLL_SCLL;
000458  e3a0105a          MOV      r1,#0x5a
00045c  e5841014          STR      r1,[r4,#0x14]
;;;558      I20SCLH   = I2SCLH_SCLH;
000460  e5841010          STR      r1,[r4,#0x10]
;;;559    
;;;560      if ( I2cMode == I2CSLAVE )
000464  e3500002          CMP      r0,#2
000468  e3a01000          MOV      r1,#0                 ;558
;;;561      {
;;;562    	I20ADR = 0x00;		//UC SHOULD NOT BE SLAVE PCA9532_ADDR;
00046c  0584100c          STREQ    r1,[r4,#0xc]
;;;563      }    
;;;564    	I2CStarted = FALSE;
000470  e59f0034          LDR      r0,|L1.1196|
000474  e5c01004          STRB     r1,[r0,#4]  ; I2CStarted
;;;565    	I2CComplete = FALSE;
000478  e5c01005          STRB     r1,[r0,#5]  ; I2CComplete
;;;566    	I2CFailed = FALSE;
00047c  e5c01006          STRB     r1,[r0,#6]  ; I2CFailed
;;;567      /* Install interrupt handler */
;;;568      //void I2C0MasterHandler(void) __irq 	
;;;569      if ( install_irq( I2C0_INT, (void (*) (void) __irq) I2C0MasterHandler, HIGHEST_PRIORITY ) == FALSE )
000480  e59f1038          LDR      r1,|L1.1216|
000484  e3a02001          MOV      r2,#1
000488  e3a00009          MOV      r0,#9
00048c  ebfffffe          BL       install_irq
000490  e3500000          CMP      r0,#0
;;;570      {
;;;571    	return( FALSE );
;;;572      }
;;;573      I20CONSET = I2CONSET_I2EN;
000494  13a00040          MOVNE    r0,#0x40
000498  15840000          STRNE    r0,[r4,#0]
;;;574      return( TRUE );
00049c  e8bd4010          POP      {r4,lr}
0004a0  13a00001          MOVNE    r0,#1
;;;575    }
0004a4  e12fff1e          BX       lr
;;;576    
                          ENDP

                  |L1.1192|
                          DCD      0xe001c000
                  |L1.1196|
                          DCD      ||.data||
                  |L1.1200|
                          DCD      ||.bss||
                  |L1.1204|
                          DCD      ||.bss||+0x10
                  |L1.1208|
                          DCD      ||.data||+0x10
                  |L1.1212|
                          DCD      0xe01fc000
                  |L1.1216|
                          DCD      I2C0MasterHandler

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  I2CWriteBuffer
                          %        16
                  I2CReadBuffer
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  RdIndex
000000  00                DCB      0x00
                  WrIndex
000001  00                DCB      0x00
                  I2CReadLength
000002  00                DCB      0x00
                  I2CWriteLength
000003  00                DCB      0x00
                  I2CStarted
000004  00                DCB      0x00
                  I2CComplete
000005  00                DCB      0x00
                  I2CFailed
000006  00                DCB      0x00
                  I2CSLA_W
000007  00                DCB      0x00
                  I2CSLA_R
000008  00                DCB      0x00
                  lastState
000009  000000            DCB      0x00,0x00,0x00
                  sysreg
                          DCD      0x00000000
                  hangTimer
                          %        8
