; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\mpu9250.o --asm_dir=.\ --list_dir=.\ --depend=.\obj\mpu9250.d --apcs=interwork --diag_suppress=9931 -IC:\Keil_v5\ARM\INC\Phillips -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -DDEVELOPMENT --omf_browse=.\obj\mpu9250.crf MPU9250.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  MPU9250Handler PROC
;;;117    
;;;118    static void MPU9250Handler(void) __irq 
000000  e92d100f          PUSH     {r0-r3,r12}
;;;119    {
;;;120    	EXTINT = (1 << 3); 	// CLEAR EINT3
000004  e59f086c          LDR      r0,|L1.2168|
000008  e3a02008          MOV      r2,#8
00000c  e5802140          STR      r2,[r0,#0x140]
;;;121    	if((IO_INT_STAT & 0x01) == 0x01) // there is a port 0 interrupt
000010  e2401975          SUB      r1,r0,#0x1d4000
000014  e5910080          LDR      r0,[r1,#0x80]
000018  e3100001          TST      r0,#1
00001c  0a00001a          BEQ      |L1.140|
;;;122    	{
;;;123    		// an interrupt from port 0
;;;124    		if((IO0_INT_STAT_R & (1 << GPIO_PIN_MPU9250_INT)) == (1 << GPIO_PIN_MPU9250_INT))
000020  e5910084          LDR      r0,[r1,#0x84]
000024  e3100802          TST      r0,#0x20000
;;;125    		{
;;;126    			// process the interrupt
;;;127    			dataAvailable = TRUE;
000028  e59f084c          LDR      r0,|L1.2172|
00002c  0a000006          BEQ      |L1.76|
000030  e3a03001          MOV      r3,#1
;;;128    			IO0_INT_CLR = (1 << GPIO_PIN_MPU9250_INT);
000034  e3a0c802          MOV      r12,#0x20000
000038  e5c03004          STRB     r3,[r0,#4]            ;127  ; dataAvailable
00003c  e581c08c          STR      r12,[r1,#0x8c]
;;;129    			if(intType == 0) intType = 1;		
000040  e5d0c005          LDRB     r12,[r0,#5]  ; intType
000044  e35c0000          CMP      r12,#0
000048  05c03005          STRBEQ   r3,[r0,#5]  ; intType
                  |L1.76|
;;;130    		}
;;;131    
;;;132    		if((IO0_INT_STAT_R & (1 << GPIO_PIN_RX0)) == (1 << GPIO_PIN_RX0))
00004c  e5913084          LDR      r3,[r1,#0x84]
000050  e3130008          TST      r3,#8
;;;133    		{
;;;134    			// process the serial debug interrupt
;;;135    			IO0_INT_CLR = (1 << GPIO_PIN_RX0);
;;;136    			if(intType == 0) intType = 2;
000054  e3a03002          MOV      r3,#2
000058  0a000003          BEQ      |L1.108|
00005c  e581208c          STR      r2,[r1,#0x8c]         ;135
000060  e5d02005          LDRB     r2,[r0,#5]  ; intType
000064  e3520000          CMP      r2,#0
000068  05c03005          STRBEQ   r3,[r0,#5]  ; intType
                  |L1.108|
;;;137    		}	
;;;138    
;;;139    		if((IO0_INT_STAT_R & (1 << GPIO_PIN_RX3)) == (1 << GPIO_PIN_RX3))
00006c  e5912084          LDR      r2,[r1,#0x84]
000070  e3120002          TST      r2,#2
000074  0a000004          BEQ      |L1.140|
;;;140    		{
;;;141    			// process the serial debug interrupt
;;;142    			IO0_INT_CLR = (1 << GPIO_PIN_RX3);
000078  e581308c          STR      r3,[r1,#0x8c]
;;;143    			if(intType == 0) intType = 3;
00007c  e5d01005          LDRB     r1,[r0,#5]  ; intType
000080  e3510000          CMP      r1,#0
000084  03a01003          MOVEQ    r1,#3
000088  05c01005          STRBEQ   r1,[r0,#5]  ; intType
                  |L1.140|
;;;144    		}	
;;;145    	}
;;;146    	VICVectAddr = 0;		// Acknowledge Interrupt	
00008c  e3a00000          MOV      r0,#0
000090  e5000100          STR      r0,[r0,#-0x100]
;;;147    }
000094  e8bd100f          POP      {r0-r3,r12}
000098  e25ef004          SUBS     pc,lr,#4
;;;148    
                          ENDP

                  writeByte PROC
;;;703    // Wire.h read and write protocols
;;;704    BOOL writeByte(BYTE address, BYTE subAddress, BYTE data)
00009c  e92d4007          PUSH     {r0-r2,lr}
;;;705    {
0000a0  e24dd010          SUB      sp,sp,#0x10
;;;706    	BOOL returnValue = FALSE;
;;;707    	BYTE dest;
;;;708    
;;;709    	returnValue = i2cDataTransaction(&data, 1, 0, address, subAddress, &dest);
0000a4  e28d2008          ADD      r2,sp,#8
0000a8  e88d0006          STM      sp,{r1,r2}
0000ac  e1a03000          MOV      r3,r0
0000b0  e3a02000          MOV      r2,#0
0000b4  e3a01001          MOV      r1,#1
0000b8  e28d0018          ADD      r0,sp,#0x18
0000bc  ebfffffe          BL       i2cDataTransaction
0000c0  e28dd01c          ADD      sp,sp,#0x1c
0000c4  e49de004          POP      {lr}
;;;710    
;;;711    	return returnValue;
;;;712    }
0000c8  e12fff1e          BX       lr
;;;713    
                          ENDP

                  write_Mag_Register PROC
;;;674    
;;;675    BOOL write_Mag_Register(unsigned char mag_register, unsigned char value)
0000cc  e92d4070          PUSH     {r4-r6,lr}
;;;676    {
0000d0  e1a04001          MOV      r4,r1
0000d4  e1a05000          MOV      r5,r0
;;;677    	BANK(3)
0000d8  e3a02030          MOV      r2,#0x30
0000dc  e3a0107f          MOV      r1,#0x7f
0000e0  e3a000d0          MOV      r0,#0xd0
0000e4  ebfffffe          BL       writeByte
;;;678    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_ADDR, 0x0C) == FALSE) return FALSE;
0000e8  e3a0200c          MOV      r2,#0xc
0000ec  e3a01003          MOV      r1,#3
0000f0  e3a000d0          MOV      r0,#0xd0
0000f4  ebfffffe          BL       writeByte
0000f8  e3500000          CMP      r0,#0
0000fc  0a000039          BEQ      |L1.488|
;;;679    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_REG, mag_register) == FALSE) return FALSE;
000100  e1a02005          MOV      r2,r5
000104  e3a01004          MOV      r1,#4
000108  e3a000d0          MOV      r0,#0xd0
00010c  ebfffffe          BL       writeByte
000110  e3500000          CMP      r0,#0
000114  0a000033          BEQ      |L1.488|
;;;680    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_DO, value) == FALSE) return FALSE;
000118  e1a02004          MOV      r2,r4
00011c  e3a01006          MOV      r1,#6
000120  e3a000d0          MOV      r0,#0xd0
000124  ebfffffe          BL       writeByte
000128  e3500000          CMP      r0,#0
00012c  0a00002d          BEQ      |L1.488|
;;;681    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_CTRL, 0x81) == FALSE) return FALSE;
000130  e3a02081          MOV      r2,#0x81
000134  e3a01005          MOV      r1,#5
000138  e3a000d0          MOV      r0,#0xd0
00013c  ebfffffe          BL       writeByte
000140  e3500000          CMP      r0,#0
000144  0a000027          BEQ      |L1.488|
;;;682    	BANK(0)
000148  e3a02000          MOV      r2,#0
00014c  e3a0107f          MOV      r1,#0x7f
000150  e3a000d0          MOV      r0,#0xd0
000154  ebfffffe          BL       writeByte
;;;683    	if(writeByte(MPU9250_ADDRESS, USER_CTRL, 0x20) == FALSE) return FALSE; 
000158  e3a02020          MOV      r2,#0x20
00015c  e3a01003          MOV      r1,#3
000160  e3a000d0          MOV      r0,#0xd0
000164  ebfffffe          BL       writeByte
000168  e3500000          CMP      r0,#0
00016c  0a00001d          BEQ      |L1.488|
;;;684    	TIME_DELAY(60) // sleep 60mS
000170  e59f0708          LDR      r0,|L1.2176|
000174  ebfffffe          BL       initTimer
000178  e59f0700          LDR      r0,|L1.2176|
00017c  e3a0103c          MOV      r1,#0x3c
000180  ebfffffe          BL       startTimer
                  |L1.388|
000184  e59f06f4          LDR      r0,|L1.2176|
000188  ebfffffe          BL       isTimerExpired
00018c  e3500000          CMP      r0,#0
000190  0afffffb          BEQ      |L1.388|
;;;685    	if(writeByte(MPU9250_ADDRESS, USER_CTRL, 0x00) == FALSE) return FALSE; 
000194  e3a02000          MOV      r2,#0
000198  e3a01003          MOV      r1,#3
00019c  e3a000d0          MOV      r0,#0xd0
0001a0  ebfffffe          BL       writeByte
0001a4  e3500000          CMP      r0,#0
0001a8  0a00000e          BEQ      |L1.488|
;;;686    	BANK(3)
0001ac  e3a02030          MOV      r2,#0x30
0001b0  e3a0107f          MOV      r1,#0x7f
0001b4  e3a000d0          MOV      r0,#0xd0
0001b8  ebfffffe          BL       writeByte
;;;687    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_CTRL, 0) == FALSE) return FALSE;
0001bc  e3a02000          MOV      r2,#0
0001c0  e3a01005          MOV      r1,#5
0001c4  e3a000d0          MOV      r0,#0xd0
0001c8  ebfffffe          BL       writeByte
0001cc  e3500000          CMP      r0,#0
0001d0  0a000004          BEQ      |L1.488|
;;;688    	BANK(0)
0001d4  e3a02000          MOV      r2,#0
0001d8  e3a0107f          MOV      r1,#0x7f
0001dc  e3a000d0          MOV      r0,#0xd0
0001e0  ebfffffe          BL       writeByte
;;;689    	
;;;690    	return TRUE;
0001e4  e3a00001          MOV      r0,#1
                  |L1.488|
0001e8  e8bd4070          POP      {r4-r6,lr}
;;;691    }
0001ec  e12fff1e          BX       lr
;;;692    
                          ENDP

                  readByte PROC
;;;713    
;;;714    BOOL readByte(BYTE address, BYTE subAddress, BYTE *dest)
0001f0  e92d401c          PUSH     {r2-r4,lr}
;;;715    {
;;;716    	BOOL returnValue = FALSE;
;;;717    
;;;718    	returnValue = i2cDataTransaction(0, 0, 1, address, subAddress, dest);
0001f4  e88d0006          STM      sp,{r1,r2}
0001f8  e1a03000          MOV      r3,r0
0001fc  e3a01000          MOV      r1,#0
000200  e3a02001          MOV      r2,#1
000204  e1a00001          MOV      r0,r1
000208  ebfffffe          BL       i2cDataTransaction
00020c  e8bd401c          POP      {r2-r4,lr}
;;;719    
;;;720    	return returnValue;
;;;721    }
000210  e12fff1e          BX       lr
;;;722    
                          ENDP

                  getAres PROC
;;;247    
;;;248    void getAres(void)
000214  e59f1660          LDR      r1,|L1.2172|
;;;249    {
;;;250    	switch (Ascale)
000218  e5d10000          LDRB     r0,[r1,#0]  ; Ascale
00021c  e3500000          CMP      r0,#0
;;;251    	{
;;;252    		// Possible accelerometer scales (and their register bit settings) are:
;;;253    		// 2 Gs (00), 4 Gs (01), 8 Gs (10), and 16 Gs  (11). 
;;;254    		// Here's a bit of an algorith to calculate DPS/(ADC tick) based on that 2-bit value:
;;;255    		case AFS_2G:
;;;256    			aRes = 2.0/32768.0;
000220  03a005e2          MOVEQ    r0,#0x38800000
000224  0a000008          BEQ      |L1.588|
000228  e3500001          CMP      r0,#1                 ;250
;;;257    			break;
;;;258    			
;;;259    		case AFS_4G:
;;;260    			aRes = 4.0/32768.0;
00022c  03a00439          MOVEQ    r0,#0x39000000
000230  0a000005          BEQ      |L1.588|
000234  e3500002          CMP      r0,#2                 ;250
;;;261    			break;
;;;262    		
;;;263    		case AFS_8G:
;;;264    			aRes = 8.0/32768.0;
000238  03a005e6          MOVEQ    r0,#0x39800000
00023c  0a000002          BEQ      |L1.588|
000240  e3500003          CMP      r0,#3                 ;250
;;;265    			break;
;;;266    			
;;;267    		case AFS_16G:
;;;268    			aRes = 16.0/32768.0;
000244  03a0043a          MOVEQ    r0,#0x3a000000
;;;269    			break;
;;;270    	}
;;;271    }
000248  112fff1e          BXNE     lr
                  |L1.588|
00024c  e5810018          STR      r0,[r1,#0x18]         ;268  ; aRes
000250  e12fff1e          BX       lr
;;;272    
                          ENDP

                  getMres PROC
;;;230    
;;;231    void getMres(void)
000254  e59f1620          LDR      r1,|L1.2172|
;;;232    {
;;;233    	switch (Mscale)
000258  e5d10001          LDRB     r0,[r1,#1]  ; Mscale
00025c  e3500000          CMP      r0,#0
;;;234    	{
;;;235    		// Possible magnetometer scales (and their register bit settings) are:
;;;236    		// 14 bit resolution (0) and 16 bit resolution (1)
;;;237    		case MFS_14BITS:
;;;238    			mRes = 4912./8190.; // Proper scale to return uT
000260  059f061c          LDREQ    r0,|L1.2180|
000264  0a000002          BEQ      |L1.628|
000268  e3500001          CMP      r0,#1                 ;233
;;;239    			break;
;;;240    			
;;;241    		case MFS_16BITS:
;;;242    			mRes = 4912./32760.0; // Proper scale to return uT
00026c  059f0614          LDREQ    r0,|L1.2184|
;;;243    			break;
;;;244    	}
;;;245    }
000270  112fff1e          BXNE     lr
                  |L1.628|
000274  e581001c          STR      r0,[r1,#0x1c]         ;238  ; mRes
000278  e12fff1e          BX       lr
;;;246    
                          ENDP

                  MPU9250 PROC
;;;149    
;;;150    BOOL MPU9250()
00027c  e92d4008          PUSH     {r3,lr}
;;;151    {
;;;152    	BYTE dummy;
;;;153    	getMres();
000280  ebfffffe          BL       getMres
;;;154    	getAres();
000284  ebfffffe          BL       getAres
;;;155    	calibrationDataACal.boardOrientaton = BOARD_ORIENTATION_Z_AXIS_UP;
000288  e59f15fc          LDR      r1,|L1.2188|
00028c  e3a00005          MOV      r0,#5
000290  e5c10010          STRB     r0,[r1,#0x10]  ; calibrationDataACal
;;;156    
;;;157    	BANK(0)
000294  e3a02000          MOV      r2,#0
000298  e3a0107f          MOV      r1,#0x7f
00029c  e3a000d0          MOV      r0,#0xd0
0002a0  ebfffffe          BL       writeByte
;;;158    	if(writeByte(MPU9250_ADDRESS, PWR_MGMT_1, 0x80) == FALSE) return FALSE;
0002a4  e3a02080          MOV      r2,#0x80
0002a8  e3a01006          MOV      r1,#6
0002ac  e3a000d0          MOV      r0,#0xd0
0002b0  ebfffffe          BL       writeByte
0002b4  e3500000          CMP      r0,#0
0002b8  0a00009a          BEQ      |L1.1320|
;;;159    	TIME_DELAY(100) // Wait for all registers to reset 
0002bc  e59f05bc          LDR      r0,|L1.2176|
0002c0  ebfffffe          BL       initTimer
0002c4  e59f05b4          LDR      r0,|L1.2176|
0002c8  e3a01064          MOV      r1,#0x64
0002cc  ebfffffe          BL       startTimer
                  |L1.720|
0002d0  e59f05a8          LDR      r0,|L1.2176|
0002d4  ebfffffe          BL       isTimerExpired
0002d8  e3500000          CMP      r0,#0
0002dc  0afffffb          BEQ      |L1.720|
;;;160    	if(writeByte(MPU9250_ADDRESS, INT_PIN_CFG, 0x02) == FALSE) return FALSE; // to enable AK8963    
0002e0  e3a02002          MOV      r2,#2
0002e4  e3a0100f          MOV      r1,#0xf
0002e8  e3a000d0          MOV      r0,#0xd0
0002ec  ebfffffe          BL       writeByte
0002f0  e3500000          CMP      r0,#0
0002f4  0a00008b          BEQ      |L1.1320|
;;;161    	if(readByte(MPU9250_ADDRESS, INT_STATUS_1, &dummy) == FALSE) return FALSE;
0002f8  e1a0200d          MOV      r2,sp
0002fc  e3a0101a          MOV      r1,#0x1a
000300  e3a000d0          MOV      r0,#0xd0
000304  ebfffffe          BL       readByte
000308  e3500000          CMP      r0,#0
00030c  0a000085          BEQ      |L1.1320|
;;;162    
;;;163    	if(writeByte(MPU9250_ADDRESS, PWR_MGMT_1, 0x01) == FALSE) return FALSE;  // Auto select clock source to be PLL gyroscope reference if ready else
000310  e3a02001          MOV      r2,#1
000314  e3a01006          MOV      r1,#6
000318  e3a000d0          MOV      r0,#0xd0
00031c  ebfffffe          BL       writeByte
000320  e3500000          CMP      r0,#0
000324  0a00007f          BEQ      |L1.1320|
;;;164    	if(writeByte(MPU9250_ADDRESS, PWR_MGMT_2, 0x07) == FALSE) return FALSE;
000328  e3a02007          MOV      r2,#7
00032c  e1a01002          MOV      r1,r2
000330  e3a000d0          MOV      r0,#0xd0
000334  ebfffffe          BL       writeByte
000338  e3500000          CMP      r0,#0
00033c  0a000079          BEQ      |L1.1320|
;;;165    	if(writeByte(MPU9250_ADDRESS, INT_ENABLE_1, 0x01) == FALSE) return FALSE;  // Enable data ready (bit 0) interrupt
000340  e3a02001          MOV      r2,#1
000344  e3a01011          MOV      r1,#0x11
000348  e3a000d0          MOV      r0,#0xd0
00034c  ebfffffe          BL       writeByte
000350  e3500000          CMP      r0,#0
000354  0a000073          BEQ      |L1.1320|
;;;166    	
;;;167    	BANK(2)
000358  e3a02020          MOV      r2,#0x20
00035c  e3a0107f          MOV      r1,#0x7f
000360  e3a000d0          MOV      r0,#0xd0
000364  ebfffffe          BL       writeByte
;;;168    	if(writeByte(MPU9250_ADDRESS, MOT_DETECT_CTRL, 0x00) == FALSE) return FALSE;
000368  e3a02000          MOV      r2,#0
00036c  e3a01012          MOV      r1,#0x12
000370  e3a000d0          MOV      r0,#0xd0
000374  ebfffffe          BL       writeByte
000378  e3500000          CMP      r0,#0
00037c  0a000069          BEQ      |L1.1320|
;;;169    
;;;170    	// 00 110 00 1  BW 5.7Hz
;;;171    	if(writeByte(MPU9250_ADDRESS, ACCEL_CONFIG, 0x31) == FALSE) return FALSE; // Write new ACCEL_CONFIG2 register value
000380  e3a02031          MOV      r2,#0x31
000384  e3a01014          MOV      r1,#0x14
000388  e3a000d0          MOV      r0,#0xd0
00038c  ebfffffe          BL       writeByte
000390  e3500000          CMP      r0,#0
000394  0a000063          BEQ      |L1.1320|
;;;172    	if(writeByte(MPU9250_ADDRESS, ACCEL_CONFIG_2, 0x02) == FALSE) return FALSE; // 2: Average 16 samples.
000398  e3a02002          MOV      r2,#2
00039c  e3a01015          MOV      r1,#0x15
0003a0  e3a000d0          MOV      r0,#0xd0
0003a4  ebfffffe          BL       writeByte
0003a8  e3500000          CMP      r0,#0
0003ac  0a00005d          BEQ      |L1.1320|
;;;173    	if(writeByte(MPU9250_ADDRESS, ACCEL_SMPLRT_DIV_1, 0x00) == FALSE) return FALSE;  // 
0003b0  e3a02000          MOV      r2,#0
0003b4  e3a01010          MOV      r1,#0x10
0003b8  e3a000d0          MOV      r0,#0xd0
0003bc  ebfffffe          BL       writeByte
0003c0  e3500000          CMP      r0,#0
0003c4  0a000057          BEQ      |L1.1320|
;;;174    	if(writeByte(MPU9250_ADDRESS, ACCEL_SMPLRT_DIV_2, 99) == FALSE) return FALSE;  // 11.25Hz
0003c8  e3a02063          MOV      r2,#0x63
0003cc  e3a01011          MOV      r1,#0x11
0003d0  e3a000d0          MOV      r0,#0xd0
0003d4  ebfffffe          BL       writeByte
0003d8  e3500000          CMP      r0,#0
0003dc  0a000051          BEQ      |L1.1320|
;;;175    
;;;176    	BANK(3)
0003e0  e3a02030          MOV      r2,#0x30
0003e4  e3a0107f          MOV      r1,#0x7f
0003e8  e3a000d0          MOV      r0,#0xd0
0003ec  ebfffffe          BL       writeByte
;;;177    	writeByte(MPU9250_ADDRESS, I2C_SLV0_CTRL, 0x00); 
0003f0  e3a02000          MOV      r2,#0
0003f4  e3a01005          MOV      r1,#5
0003f8  e3a000d0          MOV      r0,#0xd0
0003fc  ebfffffe          BL       writeByte
;;;178    	writeByte(MPU9250_ADDRESS, I2C_SLV1_CTRL, 0x00); 
000400  e3a02000          MOV      r2,#0
000404  e3a01009          MOV      r1,#9
000408  e3a000d0          MOV      r0,#0xd0
00040c  ebfffffe          BL       writeByte
;;;179    	writeByte(MPU9250_ADDRESS, I2C_SLV2_CTRL, 0x00); 
000410  e3a02000          MOV      r2,#0
000414  e3a0100d          MOV      r1,#0xd
000418  e3a000d0          MOV      r0,#0xd0
00041c  ebfffffe          BL       writeByte
;;;180    	writeByte(MPU9250_ADDRESS, I2C_SLV3_CTRL, 0x00);
000420  e3a02000          MOV      r2,#0
000424  e3a01011          MOV      r1,#0x11
000428  e3a000d0          MOV      r0,#0xd0
00042c  ebfffffe          BL       writeByte
;;;181    	
;;;182    	writeByte(MPU9250_ADDRESS, I2C_MST_CTRL, 0x10); 
000430  e3a02010          MOV      r2,#0x10
000434  e3a01001          MOV      r1,#1
000438  e3a000d0          MOV      r0,#0xd0
00043c  ebfffffe          BL       writeByte
;;;183    	writeByte(MPU9250_ADDRESS, I2C_MST_ODR_CONFIG, 0x04); 
000440  e3a02004          MOV      r2,#4
000444  e3a01000          MOV      r1,#0
000448  e3a000d0          MOV      r0,#0xd0
00044c  ebfffffe          BL       writeByte
;;;184    
;;;185    	BANK(0)
000450  e3a02000          MOV      r2,#0
000454  e3a0107f          MOV      r1,#0x7f
000458  e3a000d0          MOV      r0,#0xd0
00045c  ebfffffe          BL       writeByte
;;;186    	writeByte(MPU9250_ADDRESS, USER_CTRL, 0x00); 
000460  e3a02000          MOV      r2,#0
000464  e3a01003          MOV      r1,#3
000468  e3a000d0          MOV      r0,#0xd0
00046c  ebfffffe          BL       writeByte
;;;187    	writeByte(MPU9250_ADDRESS, LP_CONFIG, 0x40); 
000470  e3a02040          MOV      r2,#0x40
000474  e3a01005          MOV      r1,#5
000478  e3a000d0          MOV      r0,#0xd0
00047c  ebfffffe          BL       writeByte
;;;188    
;;;189    	if(write_Mag_Register(AK8963_CNTL3, 0x01) == FALSE) return FALSE; // reset the device
000480  e3a01001          MOV      r1,#1
000484  e3a00032          MOV      r0,#0x32
000488  ebfffffe          BL       write_Mag_Register
00048c  e3500000          CMP      r0,#0
000490  0a000024          BEQ      |L1.1320|
;;;190    	TIME_DELAY(5) // Wait for all registers to reset 
000494  e59f03e4          LDR      r0,|L1.2176|
000498  ebfffffe          BL       initTimer
00049c  e59f03dc          LDR      r0,|L1.2176|
0004a0  e3a01005          MOV      r1,#5
0004a4  ebfffffe          BL       startTimer
                  |L1.1192|
0004a8  e59f03d0          LDR      r0,|L1.2176|
0004ac  ebfffffe          BL       isTimerExpired
0004b0  e3500000          CMP      r0,#0
0004b4  0afffffb          BEQ      |L1.1192|
;;;191    
;;;192    	if(write_Mag_Register(AK8963_CNTL2, 0x02) == FALSE) return FALSE; // Set magnetometer data resolution and sample ODR
0004b8  e3a01002          MOV      r1,#2
0004bc  e3a00031          MOV      r0,#0x31
0004c0  ebfffffe          BL       write_Mag_Register
0004c4  e3500000          CMP      r0,#0
0004c8  0a000016          BEQ      |L1.1320|
;;;193    	TIME_DELAY(5) // Wait for all registers to reset 
0004cc  e59f03ac          LDR      r0,|L1.2176|
0004d0  ebfffffe          BL       initTimer
0004d4  e59f03a4          LDR      r0,|L1.2176|
0004d8  e3a01005          MOV      r1,#5
0004dc  ebfffffe          BL       startTimer
                  |L1.1248|
0004e0  e59f0398          LDR      r0,|L1.2176|
0004e4  ebfffffe          BL       isTimerExpired
0004e8  e3500000          CMP      r0,#0
0004ec  0afffffb          BEQ      |L1.1248|
;;;194    
;;;195    	if(install_irq(EINT3_INT, MPU9250Handler, HIGHEST_PRIORITY ) == TRUE)
0004f0  e59f1398          LDR      r1,|L1.2192|
0004f4  e3a02001          MOV      r2,#1
0004f8  e3a00011          MOV      r0,#0x11
0004fc  ebfffffe          BL       install_irq
000500  e3500001          CMP      r0,#1
000504  1a000006          BNE      |L1.1316|
;;;196    	{
;;;197    		IO0_INT_EN_R = (1 << GPIO_PIN_MPU9250_INT); // P0.17 is the interrupt
000508  e59f1384          LDR      r1,|L1.2196|
00050c  e3a00802          MOV      r0,#0x20000
000510  e5810090          STR      r0,[r1,#0x90]
;;;198    		EXTMODE = (1 << EXTMODE3); // edge
000514  e59f035c          LDR      r0,|L1.2168|
000518  e3a01008          MOV      r1,#8
00051c  e5801148          STR      r1,[r0,#0x148]
;;;199    		EXTPOLAR = (1 << EXTPOLAR3); // rising
000520  e580114c          STR      r1,[r0,#0x14c]
                  |L1.1316|
;;;200    	}
;;;201    
;;;202    	return TRUE;
000524  e3a00001          MOV      r0,#1
                  |L1.1320|
000528  e8bd4008          POP      {r3,lr}
;;;203    }
00052c  e12fff1e          BX       lr
;;;204    
                          ENDP

                  getReadReady PROC
;;;205    BOOL getReadReady(BOOL *WakeOnMotionFlag)
000530  e92d40f8          PUSH     {r3-r7,lr}
;;;206    {
;;;207    	BOOL returnValue = FALSE;
000534  e3a05000          MOV      r5,#0
;;;208    	
;;;209    	*WakeOnMotionFlag = FALSE;
;;;210    	
;;;211    	if(dataAvailable == TRUE)
000538  e59f633c          LDR      r6,|L1.2172|
00053c  e5cd5000          STRB     r5,[sp,#0]            ;207
000540  e1a04000          MOV      r4,r0                 ;206
000544  e5c05000          STRB     r5,[r0,#0]            ;209
000548  e5d60004          LDRB     r0,[r6,#4]  ; dataAvailable
00054c  e3500001          CMP      r0,#1
000550  1a00001c          BNE      |L1.1480|
;;;212    	{	
;;;213    		BANK(0)
000554  e3a02000          MOV      r2,#0
000558  e3a0107f          MOV      r1,#0x7f
00055c  e3a000d0          MOV      r0,#0xd0
000560  ebfffffe          BL       writeByte
;;;214    		if(readByte(MPU9250_ADDRESS, INT_STATUS_1, &returnValue) == FALSE) return FALSE;		
000564  e1a0200d          MOV      r2,sp
000568  e3a0101a          MOV      r1,#0x1a
00056c  e3a000d0          MOV      r0,#0xd0
000570  ebfffffe          BL       readByte
000574  e3500000          CMP      r0,#0
000578  0a000013          BEQ      |L1.1484|
;;;215    		
;;;216    		if(intType == 1 && (returnValue & 0x04) == 0x04)
00057c  e5d60005          LDRB     r0,[r6,#5]  ; intType
000580  e3500001          CMP      r0,#1
000584  1a00000a          BNE      |L1.1460|
000588  e5dd0000          LDRB     r0,[sp,#0]
00058c  e3100004          TST      r0,#4
000590  0a000007          BEQ      |L1.1460|
;;;217    		{
;;;218    			*WakeOnMotionFlag = 0x40;
000594  e3a00040          MOV      r0,#0x40
000598  e5c40000          STRB     r0,[r4,#0]
;;;219    			if(writeByte(MPU9250_ADDRESS, INT_STATUS, 0x00) == FALSE) return FALSE;
00059c  e3a02000          MOV      r2,#0
0005a0  e3a01019          MOV      r1,#0x19
0005a4  e3a000d0          MOV      r0,#0xd0
0005a8  ebfffffe          BL       writeByte
0005ac  e3500000          CMP      r0,#0
0005b0  0a000005          BEQ      |L1.1484|
                  |L1.1460|
;;;220    		}
;;;221    		
;;;222    		intType = 0;
0005b4  e5c65005          STRB     r5,[r6,#5]  ; intType
;;;223    		
;;;224    		returnValue &= 0x01;
0005b8  e5dd0000          LDRB     r0,[sp,#0]
0005bc  e2000001          AND      r0,r0,#1
0005c0  e5cd0000          STRB     r0,[sp,#0]
;;;225    		dataAvailable = FALSE;
0005c4  e5c65004          STRB     r5,[r6,#4]  ; dataAvailable
                  |L1.1480|
;;;226    	}
;;;227    	
;;;228    	return returnValue;
0005c8  e5dd0000          LDRB     r0,[sp,#0]
                  |L1.1484|
0005cc  e8bd40f8          POP      {r3-r7,lr}
;;;229    }
0005d0  e12fff1e          BX       lr
;;;230    
                          ENDP

                  calibrationDataACalInit PROC
;;;272    
;;;273    BOOL calibrationDataACalInit(BOOL checkValid)
0005d4  e59f22b0          LDR      r2,|L1.2188|
;;;274    {
0005d8  e92d4010          PUSH     {r4,lr}
;;;275    	BOOL returnValue;
;;;276    	
;;;277    	if(((checkValid == TRUE && calibrationDataACal.dataValid == CALIBRATION_VALID) || (checkValid == FALSE)) &&
0005dc  e3500001          CMP      r0,#1
0005e0  0a000002          BEQ      |L1.1520|
0005e4  e3500000          CMP      r0,#0
0005e8  0a000004          BEQ      |L1.1536|
0005ec  ea000015          B        |L1.1608|
                  |L1.1520|
0005f0  e5920000          LDR      r0,[r2,#0]  ; calibrationDataACal
0005f4  e59f129c          LDR      r1,|L1.2200|
0005f8  e1700001          CMN      r0,r1
0005fc  1a000011          BNE      |L1.1608|
                  |L1.1536|
;;;278    		calibrationDataACal.accelBias[0] > -10000 &&
000600  e5920004          LDR      r0,[r2,#4]  ; calibrationDataACal
000604  e59f1290          LDR      r1,|L1.2204|
000608  e1500001          CMP      r0,r1
;;;279    		calibrationDataACal.accelBias[0] < 10000 &&
00060c  c0413081          SUBGT    r3,r1,r1,LSL #1
000610  c1530000          CMPGT    r3,r0
000614  da00000b          BLE      |L1.1608|
;;;280    		calibrationDataACal.accelBias[1] > -10000 &&
000618  e5920008          LDR      r0,[r2,#8]  ; calibrationDataACal
00061c  e1500001          CMP      r0,r1
;;;281    		calibrationDataACal.accelBias[1] < 10000 &&
000620  c1530000          CMPGT    r3,r0
000624  da000007          BLE      |L1.1608|
;;;282    		calibrationDataACal.accelBias[2] > -10000 &&
000628  e592000c          LDR      r0,[r2,#0xc]  ; calibrationDataACal
00062c  e1500001          CMP      r0,r1
;;;283    		calibrationDataACal.accelBias[2] < 10000 &&
000630  c1530000          CMPGT    r3,r0
000634  da000003          BLE      |L1.1608|
;;;284            calibrationDataACal.boardOrientaton <= BOARD_ORIENTATION_Z_AXIS_UP)
000638  e5d20010          LDRB     r0,[r2,#0x10]  ; calibrationDataACal
00063c  e3500005          CMP      r0,#5
;;;285    	{
;;;286    		returnValue = TRUE;
000640  93a00001          MOVLS    r0,#1
000644  9a000009          BLS      |L1.1648|
                  |L1.1608|
;;;287    	}
;;;288    	else
;;;289    	{
;;;290    		calibrationDataACal.accelBias[0] = 0;
000648  e3a00000          MOV      r0,#0
;;;291    		calibrationDataACal.accelBias[1] = 0;
00064c  e5820004          STR      r0,[r2,#4]  ; calibrationDataACal
;;;292    		calibrationDataACal.accelBias[2] = 0;
000650  e5820008          STR      r0,[r2,#8]  ; calibrationDataACal
000654  e582000c          STR      r0,[r2,#0xc]  ; calibrationDataACal
;;;293            calibrationDataACal.boardOrientaton = BOARD_ORIENTATION_Z_AXIS_UP;
000658  e3a00005          MOV      r0,#5
00065c  e5c20010          STRB     r0,[r2,#0x10]  ; calibrationDataACal
;;;294    
;;;295    		strcpy(calibrationDataACal.calInfo, "CAL INIT NOT SET");
000660  e28f1f8e          ADR      r1,|L1.2208|
000664  e2820011          ADD      r0,r2,#0x11
000668  ebfffffe          BL       strcpy
;;;296    		returnValue = FALSE;
00066c  e3a00000          MOV      r0,#0
                  |L1.1648|
000670  e8bd4010          POP      {r4,lr}
;;;297    	}
;;;298    		
;;;299    	return returnValue;
;;;300    }
000674  e12fff1e          BX       lr
;;;301    
                          ENDP

                  calibrationDataMCalInit PROC
;;;302    BOOL calibrationDataMCalInit(BOOL checkValid)
000678  e59f2234          LDR      r2,|L1.2228|
;;;303    {
00067c  e92d4010          PUSH     {r4,lr}
;;;304    	BOOL returnValue;
;;;305    
;;;306    	if(((checkValid == TRUE && calibrationDataMCal.dataValid == CALIBRATION_VALID) || (checkValid == FALSE)) &&
000680  e3500001          CMP      r0,#1
000684  0a000002          BEQ      |L1.1684|
000688  e3500000          CMP      r0,#0
00068c  0a000004          BEQ      |L1.1700|
000690  ea000026          B        |L1.1840|
                  |L1.1684|
000694  e5920000          LDR      r0,[r2,#0]  ; calibrationDataMCal
000698  e59f11f8          LDR      r1,|L1.2200|
00069c  e1700001          CMN      r0,r1
0006a0  1a000022          BNE      |L1.1840|
                  |L1.1700|
;;;307    		calibrationDataMCal.magbiasInit[0] > -4000.0 &&
0006a4  e5920004          LDR      r0,[r2,#4]  ; calibrationDataMCal
0006a8  e59f1208          LDR      r1,|L1.2232|
0006ac  e1500001          CMP      r0,r1
0006b0  2a00001e          BCS      |L1.1840|
;;;308    		calibrationDataMCal.magbiasInit[0] < 4000.0 &&
0006b4  e2813102          ADD      r3,r1,#0x80000000
0006b8  e1500003          CMP      r0,r3
0006bc  aa00001b          BGE      |L1.1840|
;;;309    		calibrationDataMCal.magbiasInit[1] > -4000.0 &&
0006c0  e5920008          LDR      r0,[r2,#8]  ; calibrationDataMCal
0006c4  e1500001          CMP      r0,r1
0006c8  2a000018          BCS      |L1.1840|
;;;310    		calibrationDataMCal.magbiasInit[1] < 4000.0 &&
0006cc  e1500003          CMP      r0,r3
0006d0  aa000016          BGE      |L1.1840|
;;;311    		calibrationDataMCal.magbiasInit[2] > -4000.0 &&
0006d4  e592000c          LDR      r0,[r2,#0xc]  ; calibrationDataMCal
0006d8  e1500001          CMP      r0,r1
0006dc  2a000013          BCS      |L1.1840|
;;;312    		calibrationDataMCal.magbiasInit[2] < 4000.0 &&
0006e0  e1500003          CMP      r0,r3
0006e4  aa000011          BGE      |L1.1840|
;;;313    		calibrationDataMCal.magScaleInit[0] > -200.0 &&
0006e8  e5920010          LDR      r0,[r2,#0x10]  ; calibrationDataMCal
0006ec  e59f11c8          LDR      r1,|L1.2236|
0006f0  e1500001          CMP      r0,r1
0006f4  2a00000d          BCS      |L1.1840|
;;;314    		calibrationDataMCal.magScaleInit[0] < 200.0 &&
0006f8  e2813102          ADD      r3,r1,#0x80000000
0006fc  e1500003          CMP      r0,r3
000700  aa00000a          BGE      |L1.1840|
;;;315    		calibrationDataMCal.magScaleInit[1] > -200.0 &&
000704  e5920014          LDR      r0,[r2,#0x14]  ; calibrationDataMCal
000708  e1500001          CMP      r0,r1
00070c  2a000007          BCS      |L1.1840|
;;;316    		calibrationDataMCal.magScaleInit[1] < 200.0 &&
000710  e1500003          CMP      r0,r3
000714  aa000005          BGE      |L1.1840|
;;;317    		calibrationDataMCal.magScaleInit[2] > -200.0 &&
000718  e5920018          LDR      r0,[r2,#0x18]  ; calibrationDataMCal
00071c  e1500001          CMP      r0,r1
000720  2a000002          BCS      |L1.1840|
;;;318    		calibrationDataMCal.magScaleInit[2] < 200.0)
000724  e1500003          CMP      r0,r3
;;;319    	{
;;;320    		returnValue = TRUE;
000728  b3a00001          MOVLT    r0,#1
00072c  ba00000e          BLT      |L1.1900|
                  |L1.1840|
;;;321    	}
;;;322    	else
;;;323    	{
;;;324    		calibrationDataMCal.magbiasInit[0] = 0.0;
000730  e3a00000          MOV      r0,#0
;;;325    		calibrationDataMCal.magbiasInit[1] = 0.0;
000734  e5820004          STR      r0,[r2,#4]  ; calibrationDataMCal
;;;326    		calibrationDataMCal.magbiasInit[2] = 0.0;
;;;327    		calibrationDataMCal.magScaleInit[0] = 1.0;
000738  e3a015fe          MOV      r1,#0x3f800000
;;;328    		calibrationDataMCal.magScaleInit[1] = 1.0;
00073c  e282300c          ADD      r3,r2,#0xc
000740  e5820008          STR      r0,[r2,#8]            ;326  ; calibrationDataMCal
000744  e8830003          STM      r3,{r0,r1}  ; calibrationDataMCal, calibrationDataMCal
;;;329    		calibrationDataMCal.magScaleInit[2] = 1.0;
000748  e5821014          STR      r1,[r2,#0x14]  ; calibrationDataMCal
;;;330    		calibrationDataMCal.Orientation[0] = 0;
;;;331    		calibrationDataMCal.Orientation[1] = 0;
00074c  e582001c          STR      r0,[r2,#0x1c]  ; calibrationDataMCal, calibrationDataMCal
000750  e5821018          STR      r1,[r2,#0x18]
;;;332    		calibrationDataMCal.Orientation[2] = 0;
000754  e5820020          STR      r0,[r2,#0x20]  ; calibrationDataMCal
;;;333    		strcpy(calibrationDataMCal.calInfo, "CAL INIT NOT SET");
000758  e5820024          STR      r0,[r2,#0x24]  ; calibrationDataMCal
00075c  e28f1f4f          ADR      r1,|L1.2208|
000760  e2820028          ADD      r0,r2,#0x28
000764  ebfffffe          BL       strcpy
;;;334    		returnValue = FALSE;
000768  e3a00000          MOV      r0,#0
                  |L1.1900|
00076c  e8bd4010          POP      {r4,lr}
;;;335    	}
;;;336    		
;;;337    	return returnValue;
;;;338    }
000770  e12fff1e          BX       lr
;;;339    
                          ENDP

                  ApplyOrientation PROC
;;;340    void ApplyOrientation(float *xValue, float *yValue, float *zValue)
000774  e92d4ffe          PUSH     {r1-r11,lr}
;;;341    {
000778  e1a09000          MOV      r9,r0
;;;342        float tempX, tempY, tempZ;
;;;343        
;;;344        tempX = OrientationMatrix[calibrationDataACal.boardOrientaton][0] * *xValue + OrientationMatrix[calibrationDataACal.boardOrientaton][1] * *yValue + OrientationMatrix[calibrationDataACal.boardOrientaton][2] * *zValue;
00077c  e5920000          LDR      r0,[r2,#0]
000780  e59f6138          LDR      r6,|L1.2240|
000784  e58d0000          STR      r0,[sp,#0]
000788  e59f00fc          LDR      r0,|L1.2188|
00078c  e1a08001          MOV      r8,r1                 ;341
000790  e5d00010          LDRB     r0,[r0,#0x10]  ; calibrationDataACal
000794  e59d1000          LDR      r1,[sp,#0]
000798  e1a07002          MOV      r7,r2                 ;341
00079c  e0805180          ADD      r5,r0,r0,LSL #3
0007a0  e0864105          ADD      r4,r6,r5,LSL #2
0007a4  e5940008          LDR      r0,[r4,#8]
0007a8  ebfffffe          BL       __aeabi_fmul
0007ac  e58d0008          STR      r0,[sp,#8]
0007b0  e598b000          LDR      r11,[r8,#0]
0007b4  e5940004          LDR      r0,[r4,#4]
0007b8  e1a0100b          MOV      r1,r11
0007bc  ebfffffe          BL       __aeabi_fmul
0007c0  e58d0004          STR      r0,[sp,#4]
0007c4  e599a000          LDR      r10,[r9,#0]
0007c8  e7960105          LDR      r0,[r6,r5,LSL #2]
0007cc  e1a0100a          MOV      r1,r10
0007d0  ebfffffe          BL       __aeabi_fmul
0007d4  e59d1004          LDR      r1,[sp,#4]
0007d8  ebfffffe          BL       __aeabi_fadd
0007dc  e59d1008          LDR      r1,[sp,#8]
0007e0  ebfffffe          BL       __aeabi_fadd
0007e4  e1a06000          MOV      r6,r0
;;;345        tempY = OrientationMatrix[calibrationDataACal.boardOrientaton][3] * *xValue + OrientationMatrix[calibrationDataACal.boardOrientaton][4] * *yValue + OrientationMatrix[calibrationDataACal.boardOrientaton][5] * *zValue;
0007e8  e5940014          LDR      r0,[r4,#0x14]
0007ec  e59d1000          LDR      r1,[sp,#0]
0007f0  ebfffffe          BL       __aeabi_fmul
0007f4  e58d0004          STR      r0,[sp,#4]
0007f8  e5940010          LDR      r0,[r4,#0x10]
0007fc  e1a0100b          MOV      r1,r11
000800  ebfffffe          BL       __aeabi_fmul
000804  e1a05000          MOV      r5,r0
000808  e594000c          LDR      r0,[r4,#0xc]
00080c  e1a0100a          MOV      r1,r10
000810  ebfffffe          BL       __aeabi_fmul
000814  e1a01005          MOV      r1,r5
000818  ebfffffe          BL       __aeabi_fadd
00081c  e59d1004          LDR      r1,[sp,#4]
000820  ebfffffe          BL       __aeabi_fadd
000824  e1a05000          MOV      r5,r0
;;;346        tempZ = OrientationMatrix[calibrationDataACal.boardOrientaton][6] * *xValue + OrientationMatrix[calibrationDataACal.boardOrientaton][7] * *yValue + OrientationMatrix[calibrationDataACal.boardOrientaton][8] * *zValue;
000828  e5940020          LDR      r0,[r4,#0x20]
00082c  e59d1000          LDR      r1,[sp,#0]
000830  ebfffffe          BL       __aeabi_fmul
000834  e58d0000          STR      r0,[sp,#0]
000838  e594001c          LDR      r0,[r4,#0x1c]
00083c  e1a0100b          MOV      r1,r11
000840  ebfffffe          BL       __aeabi_fmul
000844  e1a0b000          MOV      r11,r0
000848  e5940018          LDR      r0,[r4,#0x18]
00084c  e1a0100a          MOV      r1,r10
000850  ebfffffe          BL       __aeabi_fmul
000854  e1a0100b          MOV      r1,r11
000858  ebfffffe          BL       __aeabi_fadd
00085c  e59d1000          LDR      r1,[sp,#0]
000860  ebfffffe          BL       __aeabi_fadd
;;;347    
;;;348        *xValue = tempX;
;;;349        *yValue = tempY;
000864  e5896000          STR      r6,[r9,#0]
;;;350        *zValue = tempZ;
000868  e5885000          STR      r5,[r8,#0]
00086c  e5870000          STR      r0,[r7,#0]
;;;351    }
000870  e8bd4ffe          POP      {r1-r11,lr}
000874  e12fff1e          BX       lr
                  |L1.2168|
                          DCD      0xe01fc000
                  |L1.2172|
                          DCD      ||.data||
                  |L1.2176|
                          DCD      ||.data||+0x48
                  |L1.2180|
                          DCD      0x3f198999
                  |L1.2184|
                          DCD      0x3e198999
                  |L1.2188|
                          DCD      ||area_number.4||
                  |L1.2192|
                          DCD      MPU9250Handler
                  |L1.2196|
                          DCD      0xe0028000
                  |L1.2200|
                          DCD      0x5aa52dd3
                  |L1.2204|
                          DCD      0xffffd8f0
                  |L1.2208|
0008a0  43414c20          DCB      "CAL INIT NOT SET",0
0008a4  494e4954
0008a8  204e4f54
0008ac  20534554
0008b0  00      
0008b1  00                DCB      0
0008b2  00                DCB      0
0008b3  00                DCB      0
                  |L1.2228|
                          DCD      ||area_number.4||+0x54
                  |L1.2232|
                          DCD      0xc57a0000
                  |L1.2236|
                          DCD      0xc3480000
                  |L1.2240|
                          DCD      ||.constdata||
                          ENDP

                  ApplyMagOrientation PROC
;;;352    
;;;353    void ApplyMagOrientation(float *xValue, float *yValue, float *zValue)
0008c4  e92d4ffe          PUSH     {r1-r11,lr}
;;;354    {
0008c8  e1a09000          MOV      r9,r0
;;;355        float tempX, tempY, tempZ;
;;;356        
;;;357        tempX = magOrientationMatrix[calibrationDataACal.boardOrientaton][0] * *xValue + magOrientationMatrix[calibrationDataACal.boardOrientaton][1] * *yValue + magOrientationMatrix[calibrationDataACal.boardOrientaton][2] * *zValue;
0008cc  e5920000          LDR      r0,[r2,#0]
0008d0  e59f67f4          LDR      r6,|L1.4300|
0008d4  e58d0000          STR      r0,[sp,#0]
0008d8  e51f0054          LDR      r0,|L1.2188|
0008dc  e1a08001          MOV      r8,r1                 ;354
0008e0  e5d00010          LDRB     r0,[r0,#0x10]  ; calibrationDataACal
0008e4  e59d1000          LDR      r1,[sp,#0]
0008e8  e1a07002          MOV      r7,r2                 ;354
0008ec  e0805180          ADD      r5,r0,r0,LSL #3
0008f0  e0864105          ADD      r4,r6,r5,LSL #2
0008f4  e5940008          LDR      r0,[r4,#8]
0008f8  ebfffffe          BL       __aeabi_fmul
0008fc  e58d0008          STR      r0,[sp,#8]
000900  e598b000          LDR      r11,[r8,#0]
000904  e5940004          LDR      r0,[r4,#4]
000908  e1a0100b          MOV      r1,r11
00090c  ebfffffe          BL       __aeabi_fmul
000910  e58d0004          STR      r0,[sp,#4]
000914  e599a000          LDR      r10,[r9,#0]
000918  e7960105          LDR      r0,[r6,r5,LSL #2]
00091c  e1a0100a          MOV      r1,r10
000920  ebfffffe          BL       __aeabi_fmul
000924  e59d1004          LDR      r1,[sp,#4]
000928  ebfffffe          BL       __aeabi_fadd
00092c  e59d1008          LDR      r1,[sp,#8]
000930  ebfffffe          BL       __aeabi_fadd
000934  e1a06000          MOV      r6,r0
;;;358        tempY = magOrientationMatrix[calibrationDataACal.boardOrientaton][3] * *xValue + magOrientationMatrix[calibrationDataACal.boardOrientaton][4] * *yValue + magOrientationMatrix[calibrationDataACal.boardOrientaton][5] * *zValue;
000938  e5940014          LDR      r0,[r4,#0x14]
00093c  e59d1000          LDR      r1,[sp,#0]
000940  ebfffffe          BL       __aeabi_fmul
000944  e58d0004          STR      r0,[sp,#4]
000948  e5940010          LDR      r0,[r4,#0x10]
00094c  e1a0100b          MOV      r1,r11
000950  ebfffffe          BL       __aeabi_fmul
000954  e1a05000          MOV      r5,r0
000958  e594000c          LDR      r0,[r4,#0xc]
00095c  e1a0100a          MOV      r1,r10
000960  ebfffffe          BL       __aeabi_fmul
000964  e1a01005          MOV      r1,r5
000968  ebfffffe          BL       __aeabi_fadd
00096c  e59d1004          LDR      r1,[sp,#4]
000970  ebfffffe          BL       __aeabi_fadd
000974  e1a05000          MOV      r5,r0
;;;359        tempZ = magOrientationMatrix[calibrationDataACal.boardOrientaton][6] * *xValue + magOrientationMatrix[calibrationDataACal.boardOrientaton][7] * *yValue + magOrientationMatrix[calibrationDataACal.boardOrientaton][8] * *zValue;
000978  e5940020          LDR      r0,[r4,#0x20]
00097c  e59d1000          LDR      r1,[sp,#0]
000980  ebfffffe          BL       __aeabi_fmul
000984  e58d0000          STR      r0,[sp,#0]
000988  e594001c          LDR      r0,[r4,#0x1c]
00098c  e1a0100b          MOV      r1,r11
000990  ebfffffe          BL       __aeabi_fmul
000994  e1a0b000          MOV      r11,r0
000998  e5940018          LDR      r0,[r4,#0x18]
00099c  e1a0100a          MOV      r1,r10
0009a0  ebfffffe          BL       __aeabi_fmul
0009a4  e1a0100b          MOV      r1,r11
0009a8  ebfffffe          BL       __aeabi_fadd
0009ac  e59d1000          LDR      r1,[sp,#0]
0009b0  ebfffffe          BL       __aeabi_fadd
;;;360    
;;;361        *xValue = tempX;
;;;362        *yValue = tempY;
0009b4  e5896000          STR      r6,[r9,#0]
;;;363        *zValue = tempZ;
0009b8  e5885000          STR      r5,[r8,#0]
0009bc  e5870000          STR      r0,[r7,#0]
;;;364    }
0009c0  e8bd4ffe          POP      {r1-r11,lr}
0009c4  e12fff1e          BX       lr
;;;365    
                          ENDP

                  utilityMovingAverage PROC
;;;750    
;;;751    void utilityMovingAverage(float *averageValues, float period, float value)
0009c8  e92d47f0          PUSH     {r4-r10,lr}
;;;752    {
0009cc  e1a04000          MOV      r4,r0
0009d0  e1a0a002          MOV      r10,r2
0009d4  e1a06001          MOV      r6,r1
;;;753        BYTE thePeriod = period;
0009d8  e1a00001          MOV      r0,r1
0009dc  ebfffffe          BL       __aeabi_f2uiz
0009e0  e20050ff          AND      r5,r0,#0xff
;;;754    
;;;755        memmove(&averageValues[1], &averageValues[0], thePeriod * 4);
0009e4  e1a02105          LSL      r2,r5,#2
0009e8  e1a01004          MOV      r1,r4
0009ec  e2840004          ADD      r0,r4,#4
0009f0  ebfffffe          BL       __aeabi_memmove4
;;;756        
;;;757        averageValues[0] = averageValues[1] + ((value - ((averageValues[1] + averageValues[thePeriod]) / 2.0)) / period);
0009f4  e1a00006          MOV      r0,r6
0009f8  ebfffffe          BL       __aeabi_f2d
0009fc  e5949004          LDR      r9,[r4,#4]
000a00  e1a06000          MOV      r6,r0
000a04  e1a07001          MOV      r7,r1
000a08  e7941105          LDR      r1,[r4,r5,LSL #2]
000a0c  e1a00009          MOV      r0,r9
000a10  ebfffffe          BL       __aeabi_fadd
000a14  ebfffffe          BL       __aeabi_f2d
000a18  e3e02000          MVN      r2,#0
000a1c  ebfffffe          BL       __ARM_scalbn
000a20  e1a05000          MOV      r5,r0
000a24  e1a08001          MOV      r8,r1
000a28  e1a0000a          MOV      r0,r10
000a2c  ebfffffe          BL       __aeabi_f2d
000a30  e1a02005          MOV      r2,r5
000a34  e1a03008          MOV      r3,r8
000a38  ebfffffe          BL       __aeabi_dsub
000a3c  e1a02006          MOV      r2,r6
000a40  e1a03007          MOV      r3,r7
000a44  ebfffffe          BL       __aeabi_ddiv
000a48  e1a05000          MOV      r5,r0
000a4c  e1a06001          MOV      r6,r1
000a50  e1a00009          MOV      r0,r9
000a54  ebfffffe          BL       __aeabi_f2d
000a58  e1a02005          MOV      r2,r5
000a5c  e1a03006          MOV      r3,r6
000a60  ebfffffe          BL       __aeabi_dadd
000a64  ebfffffe          BL       __aeabi_d2f
000a68  e5840000          STR      r0,[r4,#0]
;;;758    }
000a6c  e8bd47f0          POP      {r4-r10,lr}
000a70  e12fff1e          BX       lr
;;;759    
                          ENDP

                  read_Mag_Registers PROC
;;;650    
;;;651    BOOL read_Mag_Registers(unsigned char mag_register, BYTE *dest)
000a74  e92d4070          PUSH     {r4-r6,lr}
;;;652    {
000a78  e1a04001          MOV      r4,r1
000a7c  e1a05000          MOV      r5,r0
;;;653    	BANK(3)
000a80  e3a02030          MOV      r2,#0x30
000a84  e3a0107f          MOV      r1,#0x7f
000a88  e3a000d0          MOV      r0,#0xd0
000a8c  ebfffffe          BL       writeByte
;;;654    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_ADDR, 0x8C) == FALSE) return FALSE;
000a90  e3a0208c          MOV      r2,#0x8c
000a94  e3a01003          MOV      r1,#3
000a98  e3a000d0          MOV      r0,#0xd0
000a9c  ebfffffe          BL       writeByte
000aa0  e3500000          CMP      r0,#0
000aa4  0a000063          BEQ      |L1.3128|
;;;655    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_REG, mag_register) == FALSE) return FALSE;
000aa8  e1a02005          MOV      r2,r5
000aac  e3a01004          MOV      r1,#4
000ab0  e3a000d0          MOV      r0,#0xd0
000ab4  ebfffffe          BL       writeByte
000ab8  e3500000          CMP      r0,#0
000abc  0a00005d          BEQ      |L1.3128|
;;;656    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_CTRL, 0x89) == FALSE) return FALSE;
000ac0  e3a02089          MOV      r2,#0x89
000ac4  e3a01005          MOV      r1,#5
000ac8  e3a000d0          MOV      r0,#0xd0
000acc  ebfffffe          BL       writeByte
000ad0  e3500000          CMP      r0,#0
000ad4  0a000057          BEQ      |L1.3128|
;;;657    	BANK(0)
000ad8  e3a02000          MOV      r2,#0
000adc  e3a0107f          MOV      r1,#0x7f
000ae0  e3a000d0          MOV      r0,#0xd0
000ae4  ebfffffe          BL       writeByte
;;;658    	if(writeByte(MPU9250_ADDRESS, USER_CTRL, 0x20) == FALSE) return FALSE; 
000ae8  e3a02020          MOV      r2,#0x20
000aec  e3a01003          MOV      r1,#3
000af0  e3a000d0          MOV      r0,#0xd0
000af4  ebfffffe          BL       writeByte
000af8  e3500000          CMP      r0,#0
000afc  0a00004d          BEQ      |L1.3128|
;;;659    	TIME_DELAY(20) // sleep 60mS
000b00  e51f0288          LDR      r0,|L1.2176|
000b04  ebfffffe          BL       initTimer
000b08  e51f0290          LDR      r0,|L1.2176|
000b0c  e3a01014          MOV      r1,#0x14
000b10  ebfffffe          BL       startTimer
                  |L1.2836|
000b14  e51f029c          LDR      r0,|L1.2176|
000b18  ebfffffe          BL       isTimerExpired
000b1c  e3500000          CMP      r0,#0
000b20  0afffffb          BEQ      |L1.2836|
;;;660    	if(writeByte(MPU9250_ADDRESS, USER_CTRL, 0x00) == FALSE) return FALSE; 
000b24  e3a02000          MOV      r2,#0
000b28  e3a01003          MOV      r1,#3
000b2c  e3a000d0          MOV      r0,#0xd0
000b30  ebfffffe          BL       writeByte
000b34  e3500000          CMP      r0,#0
000b38  0a00003e          BEQ      |L1.3128|
;;;661    	if(readByte(MPU9250_ADDRESS, EXT_SLV_SENS_DATA_00, &(dest[0])) == FALSE) return FALSE;
000b3c  e1a02004          MOV      r2,r4
000b40  e3a0103b          MOV      r1,#0x3b
000b44  e3a000d0          MOV      r0,#0xd0
000b48  ebfffffe          BL       readByte
000b4c  e3500000          CMP      r0,#0
000b50  0a000038          BEQ      |L1.3128|
;;;662    	if(readByte(MPU9250_ADDRESS, EXT_SLV_SENS_DATA_01, &(dest[1])) == FALSE) return FALSE;
000b54  e2842001          ADD      r2,r4,#1
000b58  e3a0103c          MOV      r1,#0x3c
000b5c  e3a000d0          MOV      r0,#0xd0
000b60  ebfffffe          BL       readByte
000b64  e3500000          CMP      r0,#0
000b68  0a000032          BEQ      |L1.3128|
;;;663    	if(readByte(MPU9250_ADDRESS, EXT_SLV_SENS_DATA_02, &(dest[2])) == FALSE) return FALSE;
000b6c  e2842002          ADD      r2,r4,#2
000b70  e3a0103d          MOV      r1,#0x3d
000b74  e3a000d0          MOV      r0,#0xd0
000b78  ebfffffe          BL       readByte
000b7c  e3500000          CMP      r0,#0
000b80  0a00002c          BEQ      |L1.3128|
;;;664    	if(readByte(MPU9250_ADDRESS, EXT_SLV_SENS_DATA_03, &(dest[3])) == FALSE) return FALSE;
000b84  e2842003          ADD      r2,r4,#3
000b88  e3a0103e          MOV      r1,#0x3e
000b8c  e3a000d0          MOV      r0,#0xd0
000b90  ebfffffe          BL       readByte
000b94  e3500000          CMP      r0,#0
000b98  0a000026          BEQ      |L1.3128|
;;;665    	if(readByte(MPU9250_ADDRESS, EXT_SLV_SENS_DATA_04, &(dest[4])) == FALSE) return FALSE;
000b9c  e2842004          ADD      r2,r4,#4
000ba0  e3a0103f          MOV      r1,#0x3f
000ba4  e3a000d0          MOV      r0,#0xd0
000ba8  ebfffffe          BL       readByte
000bac  e3500000          CMP      r0,#0
000bb0  0a000020          BEQ      |L1.3128|
;;;666    	if(readByte(MPU9250_ADDRESS, EXT_SLV_SENS_DATA_05, &(dest[5])) == FALSE) return FALSE;
000bb4  e2842005          ADD      r2,r4,#5
000bb8  e3a01040          MOV      r1,#0x40
000bbc  e3a000d0          MOV      r0,#0xd0
000bc0  ebfffffe          BL       readByte
000bc4  e3500000          CMP      r0,#0
000bc8  0a00001a          BEQ      |L1.3128|
;;;667    	if(readByte(MPU9250_ADDRESS, EXT_SLV_SENS_DATA_06, &(dest[6])) == FALSE) return FALSE;
000bcc  e2842006          ADD      r2,r4,#6
000bd0  e3a01041          MOV      r1,#0x41
000bd4  e3a000d0          MOV      r0,#0xd0
000bd8  ebfffffe          BL       readByte
000bdc  e3500000          CMP      r0,#0
000be0  0a000014          BEQ      |L1.3128|
;;;668    	if(readByte(MPU9250_ADDRESS, EXT_SLV_SENS_DATA_07, &(dest[7])) == FALSE) return FALSE;
000be4  e2842007          ADD      r2,r4,#7
000be8  e3a01042          MOV      r1,#0x42
000bec  e3a000d0          MOV      r0,#0xd0
000bf0  ebfffffe          BL       readByte
000bf4  e3500000          CMP      r0,#0
000bf8  0a00000e          BEQ      |L1.3128|
;;;669    	BANK(3)
000bfc  e3a02030          MOV      r2,#0x30
000c00  e3a0107f          MOV      r1,#0x7f
000c04  e3a000d0          MOV      r0,#0xd0
000c08  ebfffffe          BL       writeByte
;;;670    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_CTRL, 0) == FALSE) return FALSE;
000c0c  e3a02000          MOV      r2,#0
000c10  e3a01005          MOV      r1,#5
000c14  e3a000d0          MOV      r0,#0xd0
000c18  ebfffffe          BL       writeByte
000c1c  e3500000          CMP      r0,#0
000c20  0a000004          BEQ      |L1.3128|
;;;671    	BANK(0)
000c24  e3a02000          MOV      r2,#0
000c28  e3a0107f          MOV      r1,#0x7f
000c2c  e3a000d0          MOV      r0,#0xd0
000c30  ebfffffe          BL       writeByte
;;;672    	return TRUE;
000c34  e3a00001          MOV      r0,#1
                  |L1.3128|
000c38  e8bd4070          POP      {r4-r6,lr}
;;;673    }
000c3c  e12fff1e          BX       lr
;;;674    
                          ENDP

                  read_Mag_Register PROC
;;;632    
;;;633    BOOL read_Mag_Register(unsigned char mag_register, BYTE *dest)
000c40  e92d4070          PUSH     {r4-r6,lr}
;;;634    {
000c44  e1a04001          MOV      r4,r1
000c48  e1a05000          MOV      r5,r0
;;;635    	BANK(3)
000c4c  e3a02030          MOV      r2,#0x30
000c50  e3a0107f          MOV      r1,#0x7f
000c54  e3a000d0          MOV      r0,#0xd0
000c58  ebfffffe          BL       writeByte
;;;636    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_ADDR, 0x8C) == FALSE) return FALSE;
000c5c  e3a0208c          MOV      r2,#0x8c
000c60  e3a01003          MOV      r1,#3
000c64  e3a000d0          MOV      r0,#0xd0
000c68  ebfffffe          BL       writeByte
000c6c  e3500000          CMP      r0,#0
000c70  0a000039          BEQ      |L1.3420|
;;;637    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_REG, mag_register) == FALSE) return FALSE;
000c74  e1a02005          MOV      r2,r5
000c78  e3a01004          MOV      r1,#4
000c7c  e3a000d0          MOV      r0,#0xd0
000c80  ebfffffe          BL       writeByte
000c84  e3500000          CMP      r0,#0
000c88  0a000033          BEQ      |L1.3420|
;;;638    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_CTRL, 0x81) == FALSE) return FALSE;
000c8c  e3a02081          MOV      r2,#0x81
000c90  e3a01005          MOV      r1,#5
000c94  e3a000d0          MOV      r0,#0xd0
000c98  ebfffffe          BL       writeByte
000c9c  e3500000          CMP      r0,#0
000ca0  0a00002d          BEQ      |L1.3420|
;;;639    	BANK(0)
000ca4  e3a02000          MOV      r2,#0
000ca8  e3a0107f          MOV      r1,#0x7f
000cac  e3a000d0          MOV      r0,#0xd0
000cb0  ebfffffe          BL       writeByte
;;;640    	if(writeByte(MPU9250_ADDRESS, USER_CTRL, 0x20) == FALSE) return FALSE; 
000cb4  e3a02020          MOV      r2,#0x20
000cb8  e3a01003          MOV      r1,#3
000cbc  e3a000d0          MOV      r0,#0xd0
000cc0  ebfffffe          BL       writeByte
000cc4  e3500000          CMP      r0,#0
000cc8  0a000023          BEQ      |L1.3420|
;;;641    	TIME_DELAY(20) // sleep 60mS  20 ok 10 no 15 ok 12 no
000ccc  e51f0454          LDR      r0,|L1.2176|
000cd0  ebfffffe          BL       initTimer
000cd4  e51f045c          LDR      r0,|L1.2176|
000cd8  e3a01014          MOV      r1,#0x14
000cdc  ebfffffe          BL       startTimer
                  |L1.3296|
000ce0  e51f0468          LDR      r0,|L1.2176|
000ce4  ebfffffe          BL       isTimerExpired
000ce8  e3500000          CMP      r0,#0
000cec  0afffffb          BEQ      |L1.3296|
;;;642    	if(writeByte(MPU9250_ADDRESS, USER_CTRL, 0x00) == FALSE) return FALSE; 
000cf0  e3a02000          MOV      r2,#0
000cf4  e3a01003          MOV      r1,#3
000cf8  e3a000d0          MOV      r0,#0xd0
000cfc  ebfffffe          BL       writeByte
000d00  e3500000          CMP      r0,#0
000d04  0a000014          BEQ      |L1.3420|
;;;643    	if(readByte(MPU9250_ADDRESS, EXT_SLV_SENS_DATA_00, dest) == FALSE) return FALSE;
000d08  e1a02004          MOV      r2,r4
000d0c  e3a0103b          MOV      r1,#0x3b
000d10  e3a000d0          MOV      r0,#0xd0
000d14  ebfffffe          BL       readByte
000d18  e3500000          CMP      r0,#0
000d1c  0a00000e          BEQ      |L1.3420|
;;;644    	BANK(3)
000d20  e3a02030          MOV      r2,#0x30
000d24  e3a0107f          MOV      r1,#0x7f
000d28  e3a000d0          MOV      r0,#0xd0
000d2c  ebfffffe          BL       writeByte
;;;645    	if(writeByte(MPU9250_ADDRESS, I2C_SLV0_CTRL, 0) == FALSE) return FALSE;
000d30  e3a02000          MOV      r2,#0
000d34  e3a01005          MOV      r1,#5
000d38  e3a000d0          MOV      r0,#0xd0
000d3c  ebfffffe          BL       writeByte
000d40  e3500000          CMP      r0,#0
000d44  0a000004          BEQ      |L1.3420|
;;;646    	BANK(0)
000d48  e3a02000          MOV      r2,#0
000d4c  e3a0107f          MOV      r1,#0x7f
000d50  e3a000d0          MOV      r0,#0xd0
000d54  ebfffffe          BL       writeByte
;;;647    
;;;648    	return TRUE;
000d58  e3a00001          MOV      r0,#1
                  |L1.3420|
000d5c  e8bd4070          POP      {r4-r6,lr}
;;;649    }
000d60  e12fff1e          BX       lr
;;;650    
                          ENDP

                  readBytes PROC
;;;722    
;;;723    BOOL readBytes(BYTE address, BYTE subAddress, BYTE count, BYTE *dest)
000d64  e92d401c          PUSH     {r2-r4,lr}
;;;724    {  
000d68  e88d000a          STM      sp,{r1,r3}
;;;725    	BOOL returnValue = FALSE;
;;;726    
;;;727    	returnValue = i2cDataTransaction(0, 0, count, address, subAddress, dest);
000d6c  e1a03000          MOV      r3,r0
000d70  e3a01000          MOV      r1,#0
000d74  e1a00001          MOV      r0,r1
000d78  ebfffffe          BL       i2cDataTransaction
000d7c  e8bd401c          POP      {r2-r4,lr}
;;;728    
;;;729    	return returnValue;
;;;730    }
000d80  e12fff1e          BX       lr
;;;731    
                          ENDP

                  ReadDataandUpdateTime PROC
;;;365    
;;;366    BOOL ReadDataandUpdateTime(void)
000d84  e92d43fe          PUSH     {r1-r9,lr}
;;;367    {
;;;368    	// ST2 register stored here, must read ST2 at end of mag data acquisition
;;;369    	BYTE rawData[8];  // x/y/z accel, mag register data stored here, temperature data
;;;370    	BOOL returnValue = FALSE;
000d88  e3a07000          MOV      r7,#0
;;;371    	BOOL WakeOnMotionFlag = FALSE;
000d8c  e1a08007          MOV      r8,r7
;;;372    		
;;;373    	if(getReadReady(&WakeOnMotionFlag) == TRUE)
000d90  e28d0008          ADD      r0,sp,#8
000d94  e5cd7008          STRB     r7,[sp,#8]            ;371
000d98  ebfffffe          BL       getReadReady
;;;374    	{
;;;375    printf("accel\n");
;;;376    		// accel, data availabe
;;;377    		BANK(0)
;;;378    		if(readBytes(MPU9250_ADDRESS, ACCEL_XOUT_H, 6, &rawData[0]) == FALSE) return FALSE;  // Read the six raw data registers into data array
;;;379    		accelCount[0] = ((short)rawData[0] << 8) | rawData[1] ;  // Turn the MSB and LSB into a signed 16-bit value
;;;380    		accelCount[1] = ((short)rawData[2] << 8) | rawData[3] ;  
;;;381    		accelCount[2] = ((short)rawData[4] << 8) | rawData[5] ; 
;;;382    
;;;383    		// Now we'll calculate the accleration value into actual g's
;;;384    		// This depends on scale being set
;;;385    		ax = (float)accelCount[0] * aRes;
000d9c  e51f4528          LDR      r4,|L1.2172|
000da0  e3500001          CMP      r0,#1                 ;373
000da4  1a00004a          BNE      |L1.3796|
000da8  e28f0e32          ADR      r0,|L1.4304|
000dac  ebfffffe          BL       __2printf
000db0  e3a02000          MOV      r2,#0                 ;377
000db4  e3a0107f          MOV      r1,#0x7f              ;377
000db8  e3a000d0          MOV      r0,#0xd0              ;377
000dbc  ebfffffe          BL       writeByte
000dc0  e1a0300d          MOV      r3,sp                 ;378
000dc4  e3a02006          MOV      r2,#6                 ;378
000dc8  e3a0102d          MOV      r1,#0x2d              ;378
000dcc  e3a000d0          MOV      r0,#0xd0              ;378
000dd0  ebfffffe          BL       readBytes
000dd4  e3500000          CMP      r0,#0                 ;378
000dd8  0a0000b9          BEQ      |L1.4292|
000ddc  e5dd0001          LDRB     r0,[sp,#1]            ;379
000de0  e5dd1000          LDRB     r1,[sp,#0]            ;379
000de4  e1800401          ORR      r0,r0,r1,LSL #8       ;379
000de8  e1a00800          LSL      r0,r0,#16             ;379
000dec  e1a00840          ASR      r0,r0,#16             ;379
000df0  e2841042          ADD      r1,r4,#0x42           ;379
000df4  e1c100b0          STRH     r0,[r1,#0]            ;379  ; accelCount
000df8  e5dd2003          LDRB     r2,[sp,#3]            ;380
000dfc  e5dd3002          LDRB     r3,[sp,#2]            ;380
000e00  e1822403          ORR      r2,r2,r3,LSL #8       ;380
000e04  e1a02802          LSL      r2,r2,#16             ;380
000e08  e1a02842          ASR      r2,r2,#16             ;380
000e0c  e1c120b2          STRH     r2,[r1,#2]            ;380  ; accelCount
000e10  e1a05002          MOV      r5,r2                 ;380
000e14  e5dd2005          LDRB     r2,[sp,#5]            ;381
000e18  e5dd3004          LDRB     r3,[sp,#4]            ;381
000e1c  e1822403          ORR      r2,r2,r3,LSL #8       ;381
000e20  e1a02802          LSL      r2,r2,#16             ;381
000e24  e1a02842          ASR      r2,r2,#16             ;381
000e28  e1a06002          MOV      r6,r2                 ;381
000e2c  e1c120b4          STRH     r2,[r1,#4]            ;381  ; accelCount
000e30  ebfffffe          BL       __aeabi_i2f
000e34  e5941018          LDR      r1,[r4,#0x18]  ; aRes
000e38  e1a09001          MOV      r9,r1
000e3c  ebfffffe          BL       __aeabi_fmul
000e40  e5840020          STR      r0,[r4,#0x20]  ; ax
000e44  e1a00005          MOV      r0,r5
;;;386    		ay = (float)accelCount[1] * aRes;
000e48  ebfffffe          BL       __aeabi_i2f
000e4c  e1a01009          MOV      r1,r9
000e50  ebfffffe          BL       __aeabi_fmul
000e54  e5840024          STR      r0,[r4,#0x24]  ; ay
000e58  e1a00006          MOV      r0,r6
;;;387    		az = (float)accelCount[2] * aRes;
000e5c  ebfffffe          BL       __aeabi_i2f
000e60  e1a01009          MOV      r1,r9
000e64  ebfffffe          BL       __aeabi_fmul
;;;388    
;;;389    		ApplyOrientation(&ax, &ay, &az);
000e68  e5840028          STR      r0,[r4,#0x28]  ; az
000e6c  e2842028          ADD      r2,r4,#0x28
000e70  e2841024          ADD      r1,r4,#0x24
000e74  e2840020          ADD      r0,r4,#0x20
000e78  ebfffffe          BL       ApplyOrientation
;;;390    		
;;;391    		if(readBytes(MPU9250_ADDRESS, TEMP_OUT_H, 2, &rawData[0]) == FALSE) return FALSE;  // Read the two raw data registers sequentially into data array 
000e7c  e1a0300d          MOV      r3,sp
000e80  e3a02002          MOV      r2,#2
000e84  e3a01039          MOV      r1,#0x39
000e88  e3a000d0          MOV      r0,#0xd0
000e8c  ebfffffe          BL       readBytes
000e90  e3500000          CMP      r0,#0
000e94  0a00008a          BEQ      |L1.4292|
;;;392    
;;;393    		tempCount = ((short)rawData[0] << 8) | rawData[1];  // Turn the MSB and LSB into a 16-bit value
000e98  e5dd0001          LDRB     r0,[sp,#1]
000e9c  e5dd1000          LDRB     r1,[sp,#0]
000ea0  e1800401          ORR      r0,r0,r1,LSL #8
000ea4  e1a00800          LSL      r0,r0,#16
000ea8  e1a00840          ASR      r0,r0,#16
000eac  e1c400b6          STRH     r0,[r4,#6]  ; tempCount
;;;394    		// Temperature in degrees Centigrade
;;;395    		temperature = ((float) tempCount) / 333.87 + 21.0;
000eb0  ebfffffe          BL       __aeabi_i2d
000eb4  e59f221c          LDR      r2,|L1.4312|
000eb8  e59f321c          LDR      r3,|L1.4316|
000ebc  ebfffffe          BL       __aeabi_ddiv
000ec0  e59f3218          LDR      r3,|L1.4320|
000ec4  e3a02000          MOV      r2,#0
000ec8  ebfffffe          BL       __aeabi_dadd
000ecc  ebfffffe          BL       __aeabi_d2f
000ed0  e5840038          STR      r0,[r4,#0x38]  ; temperature
                  |L1.3796|
;;;396    	}
;;;397    	
;;;398    	// Wait for magnetometer data ready bit to be set
;;;399    	memset(rawData, 0, sizeof(rawData));
;;;400    	if(read_Mag_Register(AK8963_ST1, &rawData[0]) == TRUE && (rawData[0] & 0x01) && read_Mag_Registers(AK8963_XOUT_L, &rawData[0]) == TRUE && (rawData[7] & 0x08) == 0)
000ed4  e1a0100d          MOV      r1,sp
000ed8  e3a00010          MOV      r0,#0x10
000edc  e58d8000          STR      r8,[sp,#0]            ;399
000ee0  e58d8004          STR      r8,[sp,#4]            ;399
000ee4  ebfffffe          BL       read_Mag_Register
000ee8  e3500001          CMP      r0,#1
000eec  1a000073          BNE      |L1.4288|
000ef0  e5dd0000          LDRB     r0,[sp,#0]
000ef4  e3100001          TST      r0,#1
000ef8  0a000070          BEQ      |L1.4288|
000efc  e1a0100d          MOV      r1,sp
000f00  e3a00011          MOV      r0,#0x11
000f04  ebfffffe          BL       read_Mag_Registers
000f08  e3500001          CMP      r0,#1
000f0c  05dd0007          LDRBEQ   r0,[sp,#7]
000f10  03100008          TSTEQ    r0,#8
000f14  1a000069          BNE      |L1.4288|
;;;401    	{
;;;402    		// Turn the MSB and LSB into a signed 16-bit value
;;;403    		magCount[0] = ((short)rawData[1] << 8) | rawData[0];
000f18  e5dd0000          LDRB     r0,[sp,#0]
000f1c  e5dd1001          LDRB     r1,[sp,#1]
000f20  e59f21bc          LDR      r2,|L1.4324|
000f24  e1800401          ORR      r0,r0,r1,LSL #8
000f28  e1a01800          LSL      r1,r0,#16
000f2c  e1a01841          ASR      r1,r1,#16
000f30  e1c210b0          STRH     r1,[r2,#0]  ; magCount
;;;404    		// Data stored as little Endian 
;;;405    		magCount[1] = ((short)rawData[3] << 8) | rawData[2];
000f34  e5dd0002          LDRB     r0,[sp,#2]
000f38  e5dd3003          LDRB     r3,[sp,#3]
000f3c  e1800403          ORR      r0,r0,r3,LSL #8
000f40  e1a00800          LSL      r0,r0,#16
000f44  e1a00840          ASR      r0,r0,#16
000f48  e1c200b2          STRH     r0,[r2,#2]  ; magCount
000f4c  e1a05000          MOV      r5,r0
;;;406    		magCount[2] = ((short)rawData[5] << 8) | rawData[4];
000f50  e5dd0004          LDRB     r0,[sp,#4]
000f54  e5dd3005          LDRB     r3,[sp,#5]
000f58  e1800403          ORR      r0,r0,r3,LSL #8
000f5c  e1a00800          LSL      r0,r0,#16
000f60  e1a00840          ASR      r0,r0,#16
000f64  e1a06000          MOV      r6,r0
000f68  e1c200b4          STRH     r0,[r2,#4]  ; magCount
;;;407    
;;;408    		// Calculate the magnetometer values in milliGauss
;;;409    		// Include factory calibration per data sheet and user environmental
;;;410    		// corrections
;;;411    		// Get actual magnetometer value, this depends on scale being set
;;;412    		mx = (float)magCount[0] * mRes;
000f6c  e1a00001          MOV      r0,r1
000f70  ebfffffe          BL       __aeabi_i2f
000f74  e594101c          LDR      r1,[r4,#0x1c]  ; mRes
000f78  e1a07001          MOV      r7,r1
000f7c  ebfffffe          BL       __aeabi_fmul
000f80  e1a08000          MOV      r8,r0
000f84  e584002c          STR      r0,[r4,#0x2c]  ; mx
000f88  e1a00005          MOV      r0,r5
;;;413    		my = (float)magCount[1] * mRes;
000f8c  ebfffffe          BL       __aeabi_i2f
000f90  e1a01007          MOV      r1,r7
000f94  ebfffffe          BL       __aeabi_fmul
000f98  e5840030          STR      r0,[r4,#0x30]  ; my
000f9c  e1a00006          MOV      r0,r6
;;;414    		mz = (float)magCount[2] * mRes;
000fa0  ebfffffe          BL       __aeabi_i2f
000fa4  e1a01007          MOV      r1,r7
000fa8  ebfffffe          BL       __aeabi_fmul
;;;415    
;;;416    		utilityMovingAverage(MxResultsFiltered, MovingAveragePeriod, mx);
000fac  e5840034          STR      r0,[r4,#0x34]  ; mz
000fb0  e59f0130          LDR      r0,|L1.4328|
000fb4  e5941014          LDR      r1,[r4,#0x14]  ; MovingAveragePeriod
000fb8  e1a02008          MOV      r2,r8                 ;414
000fbc  ebfffffe          BL       utilityMovingAverage
;;;417    		utilityMovingAverage(MyResultsFiltered, MovingAveragePeriod, my);
000fc0  e59f0124          LDR      r0,|L1.4332|
000fc4  e5941014          LDR      r1,[r4,#0x14]  ; my, MovingAveragePeriod
000fc8  e5942030          LDR      r2,[r4,#0x30]
000fcc  ebfffffe          BL       utilityMovingAverage
;;;418    		utilityMovingAverage(MzResultsFiltered, MovingAveragePeriod, mz);
000fd0  e59f0118          LDR      r0,|L1.4336|
000fd4  e5941014          LDR      r1,[r4,#0x14]  ; mz, MovingAveragePeriod
000fd8  e5942034          LDR      r2,[r4,#0x34]
000fdc  ebfffffe          BL       utilityMovingAverage
;;;419    		
;;;420    		mx = MxResultsFiltered[0];
000fe0  e59f0100          LDR      r0,|L1.4328|
;;;421    		my = MyResultsFiltered[0];
000fe4  e59f1100          LDR      r1,|L1.4332|
000fe8  e5900000          LDR      r0,[r0,#0]            ;420  ; MxResultsFiltered
000fec  e584002c          STR      r0,[r4,#0x2c]  ; mx
000ff0  e5915000          LDR      r5,[r1,#0]  ; MyResultsFiltered
;;;422    		mz = MzResultsFiltered[0];
000ff4  e2811e1e          ADD      r1,r1,#0x1e0
000ff8  e5845030          STR      r5,[r4,#0x30]  ; my
000ffc  e5916000          LDR      r6,[r1,#0]  ; MzResultsFiltered
001000  e5846034          STR      r6,[r4,#0x34]  ; mz
;;;423    		
;;;424    		if(inCalibration == 0)
001004  e5d41003          LDRB     r1,[r4,#3]  ; inCalibration
001008  e3510000          CMP      r1,#0
00100c  0a00003a          BEQ      |L1.4348|
;;;425    		{
;;;426    			// Calculate the magnetometer values in milliGauss
;;;427    			// Include factory calibration per data sheet and user environmental
;;;428    			// corrections
;;;429    			// Get actual magnetometer value, this depends on scale being set
;;;430    
;;;431    			mx -= calibrationDataMCal.magbiasInit[0];
;;;432    			my -= calibrationDataMCal.magbiasInit[1];
;;;433    			mz -= calibrationDataMCal.magbiasInit[2];
;;;434    
;;;435    			ApplyMagOrientation(&mx, &my, &mz);
;;;436    		}
;;;437    		else
;;;438    		{
;;;439    			if((inCalibration & 1) == 1)
;;;440    			{
;;;441    				if(mx > mag_max[0]) mag_max[0] = mx;
001010  e59f50dc          LDR      r5,|L1.4340|
001014  e3110001          TST      r1,#1                 ;439
;;;442    				if(mx < mag_min[0]) mag_min[0] = mx;
001018  e285600c          ADD      r6,r5,#0xc
00101c  0a00001c          BEQ      |L1.4244|
001020  e5951000          LDR      r1,[r5,#0]            ;441  ; mag_max
001024  ebfffffe          BL       __aeabi_cfrcmple
001028  3594002c          LDRCC    r0,[r4,#0x2c]         ;441  ; mx
00102c  35850000          STRCC    r0,[r5,#0]            ;441  ; mag_max
001030  e5961000          LDR      r1,[r6,#0]  ; mag_min
001034  e594002c          LDR      r0,[r4,#0x2c]  ; mx
001038  ebfffffe          BL       __aeabi_cfcmple
00103c  3594002c          LDRCC    r0,[r4,#0x2c]  ; mx
001040  35860000          STRCC    r0,[r6,#0]  ; mag_min
;;;443    				if(my > mag_max[1]) mag_max[1] = my;
001044  e5951004          LDR      r1,[r5,#4]  ; mag_max
001048  e5940030          LDR      r0,[r4,#0x30]  ; my
00104c  ebfffffe          BL       __aeabi_cfrcmple
001050  35940030          LDRCC    r0,[r4,#0x30]  ; my
001054  35850004          STRCC    r0,[r5,#4]  ; mag_max
;;;444    				if(my < mag_min[1]) mag_min[1] = my;
001058  e5961004          LDR      r1,[r6,#4]  ; mag_min
00105c  e5940030          LDR      r0,[r4,#0x30]  ; my
001060  ebfffffe          BL       __aeabi_cfcmple
001064  35940030          LDRCC    r0,[r4,#0x30]  ; my
001068  35860004          STRCC    r0,[r6,#4]  ; mag_min
;;;445    				if(mz > mag_max[2]) mag_max[2] = mz;
00106c  e5951008          LDR      r1,[r5,#8]  ; mag_max
001070  e5940034          LDR      r0,[r4,#0x34]  ; mz
001074  ebfffffe          BL       __aeabi_cfrcmple
001078  35940034          LDRCC    r0,[r4,#0x34]  ; mz
00107c  35850008          STRCC    r0,[r5,#8]  ; mag_max
;;;446    				if(mz < mag_min[2]) mag_min[2] = mz;
001080  e5961008          LDR      r1,[r6,#8]  ; mag_min
001084  e5940034          LDR      r0,[r4,#0x34]  ; mz
001088  ebfffffe          BL       __aeabi_cfcmple
00108c  35940034          LDRCC    r0,[r4,#0x34]  ; mz
001090  35860008          STRCC    r0,[r6,#8]  ; mag_min
                  |L1.4244|
;;;447    			}
;;;448    		}
;;;449    		
;;;450    		// Calculate the time the last update took for use in the quaternion filters
;;;451    		// Must be called before updating quaternions!
;;;452    		Now = getTimerNow();
001094  ebfffffe          BL       getTimerNow
001098  e1a05000          MOV      r5,r0
00109c  e584000c          STR      r0,[r4,#0xc]  ; Now
;;;453    
;;;454    		// Set integration time by time elapsed since last filter update
;;;455    		deltat = ((Now - lastUpdate) / 1000.0f);
0010a0  e5940008          LDR      r0,[r4,#8]  ; lastUpdate
0010a4  e0450000          SUB      r0,r5,r0
0010a8  ebfffffe          BL       __aeabi_ui2f
0010ac  e59f1044          LDR      r1,|L1.4344|
0010b0  ebfffffe          BL       __aeabi_fdiv
;;;456    		lastUpdate = Now;
;;;457    
;;;458    		returnValue = TRUE;
0010b4  e5a45008          STR      r5,[r4,#8]!  ; deltat, lastUpdate
0010b8  e3a07001          MOV      r7,#1
0010bc  e5840008          STR      r0,[r4,#8]
                  |L1.4288|
;;;459    	}
;;;460    
;;;461    	return returnValue;
0010c0  e1a00007          MOV      r0,r7
                  |L1.4292|
0010c4  e8bd43fe          POP      {r1-r9,lr}
;;;462    }
0010c8  e12fff1e          BX       lr
                  |L1.4300|
                          DCD      ||.constdata||+0xd8
                  |L1.4304|
0010d0  61636365          DCB      "accel\n",0
0010d4  6c0a00  
0010d7  00                DCB      0
                  |L1.4312|
                          DCD      0x851eb852
                  |L1.4316|
                          DCD      0x4074ddeb
                  |L1.4320|
                          DCD      0x40350000
                  |L1.4324|
                          DCD      ||.data||+0x3c
                  |L1.4328|
                          DCD      ||area_number.4||+0xbc
                  |L1.4332|
                          DCD      ||area_number.4||+0x29c
                  |L1.4336|
                          DCD      ||area_number.4||+0x47c
                  |L1.4340|
                          DCD      ||area_number.4||+0x674
                  |L1.4344|
                          DCD      0x447a0000
                  |L1.4348|
0010fc  e51f7850          LDR      r7,|L1.2228|
001100  e5971004          LDR      r1,[r7,#4]            ;431  ; calibrationDataMCal
001104  ebfffffe          BL       __aeabi_fsub
001108  e584002c          STR      r0,[r4,#0x2c]         ;432  ; mx
00110c  e5971008          LDR      r1,[r7,#8]            ;432  ; calibrationDataMCal
001110  e1a00005          MOV      r0,r5                 ;432
001114  ebfffffe          BL       __aeabi_fsub
001118  e5840030          STR      r0,[r4,#0x30]         ;433  ; my
00111c  e597100c          LDR      r1,[r7,#0xc]          ;433  ; calibrationDataMCal
001120  e1a00006          MOV      r0,r6                 ;433
001124  ebfffffe          BL       __aeabi_fsub
001128  e59f278c          LDR      r2,|L1.6332|
00112c  e5840034          STR      r0,[r4,#0x34]         ;435  ; mz
001130  e2421004          SUB      r1,r2,#4              ;435
001134  e2420008          SUB      r0,r2,#8              ;435
001138  ebfffffe          BL       ApplyMagOrientation
00113c  eaffffd4          B        |L1.4244|
;;;463    
                          ENDP

                  calibrateMPU9250 PROC
;;;466    // loads the resulting offsets into accelerometer bias registers.
;;;467    BOOL calibrateMPU9250(void)
001140  e92d47ff          PUSH     {r0-r10,lr}
;;;468    {  
;;;469    	BOOL returnValue;
;;;470    	unsigned short ii, jj, packet_count, fifo_count, total_packets;
;;;471    	unsigned short  accelsensitivity = 16384;  // = 16384 LSB/g
;;;472        BYTE data[6]; // data array to hold accelerometer x, y, z, data
;;;473        short accel_temp[3];
;;;474        
;;;475        calibrationDataACal.accelBias[0] = 0;
001144  e51f58c0          LDR      r5,|L1.2188|
001148  e3a00000          MOV      r0,#0
;;;476        calibrationDataACal.accelBias[1] = 0;
00114c  e5850004          STR      r0,[r5,#4]  ; calibrationDataACal
;;;477        calibrationDataACal.accelBias[2] = 0;
001150  e5850008          STR      r0,[r5,#8]  ; calibrationDataACal
;;;478        
;;;479    	// reset device
;;;480    	// Write a one to bit 7 reset bit; toggle reset device
;;;481    	if(writeByte(MPU9250_ADDRESS, PWR_MGMT_1, 0x80) == FALSE) return FALSE;
001154  e585000c          STR      r0,[r5,#0xc]  ; calibrationDataACal
001158  e3a09901          MOV      r9,#0x4000            ;471
00115c  e3a02080          MOV      r2,#0x80
001160  e3a01006          MOV      r1,#6
001164  e3a000d0          MOV      r0,#0xd0
001168  ebfffffe          BL       writeByte
00116c  e3500000          CMP      r0,#0
001170  0a00012e          BEQ      |L1.5680|
;;;482    	TIME_DELAY(100)
001174  e51f08fc          LDR      r0,|L1.2176|
001178  ebfffffe          BL       initTimer
00117c  e51f0904          LDR      r0,|L1.2176|
001180  e3a01064          MOV      r1,#0x64
001184  ebfffffe          BL       startTimer
                  |L1.4488|
001188  e51f0910          LDR      r0,|L1.2176|
00118c  ebfffffe          BL       isTimerExpired
001190  e3500000          CMP      r0,#0
001194  0afffffb          BEQ      |L1.4488|
;;;483    
;;;484    	// get stable time source; Auto select clock source to be PLL gyroscope
;;;485    	// reference if ready else use the internal oscillator, bits 2:0 = 001
;;;486    	BANK(0)
001198  e3a02000          MOV      r2,#0
00119c  e3a0107f          MOV      r1,#0x7f
0011a0  e3a000d0          MOV      r0,#0xd0
0011a4  ebfffffe          BL       writeByte
;;;487    	if(writeByte(MPU9250_ADDRESS, PWR_MGMT_1, 0x01) == FALSE) return FALSE;  
0011a8  e3a02001          MOV      r2,#1
0011ac  e3a01006          MOV      r1,#6
0011b0  e3a000d0          MOV      r0,#0xd0
0011b4  ebfffffe          BL       writeByte
0011b8  e3500000          CMP      r0,#0
0011bc  0a00011b          BEQ      |L1.5680|
;;;488    	if(writeByte(MPU9250_ADDRESS, PWR_MGMT_2, 0x00) == FALSE) return FALSE;
0011c0  e3a02000          MOV      r2,#0
0011c4  e3a01007          MOV      r1,#7
0011c8  e3a000d0          MOV      r0,#0xd0
0011cc  ebfffffe          BL       writeByte
0011d0  e3500000          CMP      r0,#0
0011d4  0a000115          BEQ      |L1.5680|
;;;489    	TIME_DELAY(200)                              
0011d8  e51f0960          LDR      r0,|L1.2176|
0011dc  ebfffffe          BL       initTimer
0011e0  e51f0968          LDR      r0,|L1.2176|
0011e4  e3a010c8          MOV      r1,#0xc8
0011e8  ebfffffe          BL       startTimer
                  |L1.4588|
0011ec  e51f0974          LDR      r0,|L1.2176|
0011f0  ebfffffe          BL       isTimerExpired
0011f4  e3500000          CMP      r0,#0
0011f8  0afffffb          BEQ      |L1.4588|
;;;490    
;;;491    	// Configure device for bias calculation
;;;492    	if(writeByte(MPU9250_ADDRESS, INT_ENABLE_1, 0x00) == FALSE) return FALSE;   // Disable all interrupts
0011fc  e3a02000          MOV      r2,#0
001200  e3a01011          MOV      r1,#0x11
001204  e3a000d0          MOV      r0,#0xd0
001208  ebfffffe          BL       writeByte
00120c  e3500000          CMP      r0,#0
001210  0a000106          BEQ      |L1.5680|
;;;493    	if(writeByte(MPU9250_ADDRESS, FIFO_EN_1, 0x00) == FALSE) return FALSE;      // Disable FIFO
001214  e3a02000          MOV      r2,#0
001218  e3a01066          MOV      r1,#0x66
00121c  e3a000d0          MOV      r0,#0xd0
001220  ebfffffe          BL       writeByte
001224  e3500000          CMP      r0,#0
001228  0a000100          BEQ      |L1.5680|
;;;494    	if(writeByte(MPU9250_ADDRESS, FIFO_EN_2, 0x00) == FALSE) return FALSE;      // Disable FIFO
00122c  e3a02000          MOV      r2,#0
001230  e3a01067          MOV      r1,#0x67
001234  e3a000d0          MOV      r0,#0xd0
001238  ebfffffe          BL       writeByte
00123c  e3500000          CMP      r0,#0
001240  0a0000fa          BEQ      |L1.5680|
;;;495    	if(writeByte(MPU9250_ADDRESS, PWR_MGMT_1, 0x00) == FALSE) return FALSE;   // Turn on internal clock source
001244  e3a02000          MOV      r2,#0
001248  e3a01006          MOV      r1,#6
00124c  e3a000d0          MOV      r0,#0xd0
001250  ebfffffe          BL       writeByte
001254  e3500000          CMP      r0,#0
001258  0a0000f4          BEQ      |L1.5680|
;;;496    	BANK(3)
00125c  e3a02030          MOV      r2,#0x30
001260  e3a0107f          MOV      r1,#0x7f
001264  e3a000d0          MOV      r0,#0xd0
001268  ebfffffe          BL       writeByte
;;;497    	if(writeByte(MPU9250_ADDRESS, I2C_MST_CTRL, 0x00) == FALSE) return FALSE; // Disable I2C master
00126c  e3a02000          MOV      r2,#0
001270  e3a01001          MOV      r1,#1
001274  e3a000d0          MOV      r0,#0xd0
001278  ebfffffe          BL       writeByte
00127c  e3500000          CMP      r0,#0
001280  0a0000ea          BEQ      |L1.5680|
;;;498    	BANK(0)
001284  e3a02000          MOV      r2,#0
001288  e3a0107f          MOV      r1,#0x7f
00128c  e3a000d0          MOV      r0,#0xd0
001290  ebfffffe          BL       writeByte
;;;499    	if(writeByte(MPU9250_ADDRESS, USER_CTRL, 0x00) == FALSE) return FALSE;    // Disable FIFO and I2C master modes
001294  e3a02000          MOV      r2,#0
001298  e3a01003          MOV      r1,#3
00129c  e3a000d0          MOV      r0,#0xd0
0012a0  ebfffffe          BL       writeByte
0012a4  e3500000          CMP      r0,#0
0012a8  0a0000e0          BEQ      |L1.5680|
;;;500    	if(writeByte(MPU9250_ADDRESS, USER_CTRL, 0x0C) == FALSE) return FALSE;    // Reset FIFO and DMP
0012ac  e3a0200c          MOV      r2,#0xc
0012b0  e3a01003          MOV      r1,#3
0012b4  e3a000d0          MOV      r0,#0xd0
0012b8  ebfffffe          BL       writeByte
0012bc  e3500000          CMP      r0,#0
0012c0  0a0000da          BEQ      |L1.5680|
;;;501    	TIME_DELAY(15)
0012c4  e51f0a4c          LDR      r0,|L1.2176|
0012c8  ebfffffe          BL       initTimer
0012cc  e51f0a54          LDR      r0,|L1.2176|
0012d0  e3a0100f          MOV      r1,#0xf
0012d4  ebfffffe          BL       startTimer
                  |L1.4824|
0012d8  e51f0a60          LDR      r0,|L1.2176|
0012dc  ebfffffe          BL       isTimerExpired
0012e0  e3500000          CMP      r0,#0
0012e4  0afffffb          BEQ      |L1.4824|
;;;502      
;;;503    	// Configure MPU6050 accelerometer for bias calculation
;;;504    	BANK(2)
0012e8  e3a02020          MOV      r2,#0x20
0012ec  e3a0107f          MOV      r1,#0x7f
0012f0  e3a000d0          MOV      r0,#0xd0
0012f4  ebfffffe          BL       writeByte
;;;505    	if(writeByte(MPU9250_ADDRESS, ACCEL_SMPLRT_DIV_1, 0x00) == FALSE) return FALSE;  // 1.125 kHz/(1+ACCEL_SMPLRT_DIV[11:0])
0012f8  e3a02000          MOV      r2,#0
0012fc  e3a01010          MOV      r1,#0x10
001300  e3a000d0          MOV      r0,#0xd0
001304  ebfffffe          BL       writeByte
001308  e3500000          CMP      r0,#0
00130c  0a0000c7          BEQ      |L1.5680|
;;;506    	if(writeByte(MPU9250_ADDRESS, ACCEL_SMPLRT_DIV_2, 0x00) == FALSE) return FALSE;  
001310  e3a02000          MOV      r2,#0
001314  e3a01011          MOV      r1,#0x11
001318  e3a000d0          MOV      r0,#0xd0
00131c  ebfffffe          BL       writeByte
001320  e3500000          CMP      r0,#0
001324  0a0000c1          BEQ      |L1.5680|
;;;507    	if(writeByte(MPU9250_ADDRESS, ACCEL_CONFIG, 0x00) == FALSE) return FALSE; // Set accelerometer full-scale to 2 g, maximum sensitivity
001328  e3a02000          MOV      r2,#0
00132c  e3a01014          MOV      r1,#0x14
001330  e3a000d0          MOV      r0,#0xd0
001334  ebfffffe          BL       writeByte
001338  e3500000          CMP      r0,#0
00133c  0a0000bb          BEQ      |L1.5680|
;;;508    
;;;509        total_packets = 0;
001340  e3a06000          MOV      r6,#0
;;;510    	BANK(0)
001344  e1a02006          MOV      r2,r6
001348  e3a0107f          MOV      r1,#0x7f
00134c  e3a000d0          MOV      r0,#0xd0
001350  ebfffffe          BL       writeByte
;;;511        for (jj = 0; jj < 10; jj++)
001354  e3a07000          MOV      r7,#0
001358  e1a0a00d          MOV      r10,sp                ;472
                  |L1.4956|
;;;512        {
;;;513        	// Configure FIFO to capture accelerometer data for bias calculation
;;;514        	if(writeByte(MPU9250_ADDRESS, USER_CTRL, 0x40) == FALSE) return FALSE;   // Enable FIFO  
00135c  e3a02040          MOV      r2,#0x40
001360  e3a01003          MOV      r1,#3
001364  e3a000d0          MOV      r0,#0xd0
001368  ebfffffe          BL       writeByte
00136c  e3500000          CMP      r0,#0
001370  0a0000ae          BEQ      |L1.5680|
;;;515        	if(writeByte(MPU9250_ADDRESS, FIFO_EN_2, 0x10) == FALSE) return FALSE;     // Enable accelerometer sensors for FIFO  (max size 512 bytes in MPU-9150)
001374  e3a02010          MOV      r2,#0x10
001378  e3a01067          MOV      r1,#0x67
00137c  e3a000d0          MOV      r0,#0xd0
001380  ebfffffe          BL       writeByte
001384  e3500000          CMP      r0,#0
001388  0a0000a8          BEQ      |L1.5680|
;;;516    		TIME_DELAY(40) // accumulate 40 samples in 40 milliseconds = 480 bytes
00138c  e51f0b14          LDR      r0,|L1.2176|
001390  ebfffffe          BL       initTimer
001394  e51f0b1c          LDR      r0,|L1.2176|
001398  e3a01028          MOV      r1,#0x28
00139c  ebfffffe          BL       startTimer
                  |L1.5024|
0013a0  e51f0b28          LDR      r0,|L1.2176|
0013a4  ebfffffe          BL       isTimerExpired
0013a8  e3500000          CMP      r0,#0
0013ac  0afffffb          BEQ      |L1.5024|
;;;517        
;;;518        	// At end of sample accumulation, turn off FIFO sensor read
;;;519        	if(writeByte(MPU9250_ADDRESS, FIFO_EN_2, 0x00) == FALSE) return FALSE;        // Disable accelerometer sensors for FIFO
0013b0  e3a02000          MOV      r2,#0
0013b4  e3a01067          MOV      r1,#0x67
0013b8  e3a000d0          MOV      r0,#0xd0
0013bc  ebfffffe          BL       writeByte
0013c0  e3500000          CMP      r0,#0
0013c4  0a000099          BEQ      |L1.5680|
;;;520        	if(readBytes(MPU9250_ADDRESS, FIFO_COUNTH, 2, &data[0]) == FALSE) return FALSE; // read FIFO sample count
0013c8  e1a0300d          MOV      r3,sp
0013cc  e3a02002          MOV      r2,#2
0013d0  e3a01070          MOV      r1,#0x70
0013d4  e3a000d0          MOV      r0,#0xd0
0013d8  ebfffffe          BL       readBytes
0013dc  e3500000          CMP      r0,#0
0013e0  0a000092          BEQ      |L1.5680|
;;;521        	fifo_count = ((unsigned short)data[0] << 8) | data[1];
0013e4  e5dd0001          LDRB     r0,[sp,#1]
0013e8  e5dd1000          LDRB     r1,[sp,#0]
0013ec  e1800401          ORR      r0,r0,r1,LSL #8
;;;522        	packet_count = fifo_count/6;// How many sets of full accelerometer data for averaging
0013f0  e3a01006          MOV      r1,#6
0013f4  ebfffffe          BL       __aeabi_uidivmod
0013f8  e1a08000          MOV      r8,r0
;;;523        
;;;524            for (ii = 0; ii < packet_count; ii++, total_packets++)
0013fc  e3a04000          MOV      r4,#0
001400  ea000042          B        |L1.5392|
                  |L1.5124|
;;;525            {
;;;526    
;;;527        		if(readByte(MPU9250_ADDRESS, FIFO_R_W, &data[0]) == FALSE) return FALSE; // read data for averaging
001404  e1a0200d          MOV      r2,sp
001408  e3a01072          MOV      r1,#0x72
00140c  e3a000d0          MOV      r0,#0xd0
001410  ebfffffe          BL       readByte
001414  e3500000          CMP      r0,#0
001418  0a000084          BEQ      |L1.5680|
;;;528        		if(readByte(MPU9250_ADDRESS, FIFO_R_W, &data[1]) == FALSE) return FALSE; // read data for averaging
00141c  e28a2001          ADD      r2,r10,#1
001420  e3a01072          MOV      r1,#0x72
001424  e3a000d0          MOV      r0,#0xd0
001428  ebfffffe          BL       readByte
00142c  e3500000          CMP      r0,#0
001430  0a00007e          BEQ      |L1.5680|
;;;529        		if(readByte(MPU9250_ADDRESS, FIFO_R_W, &data[2]) == FALSE) return FALSE; // read data for averaging
001434  e28a2002          ADD      r2,r10,#2
001438  e3a01072          MOV      r1,#0x72
00143c  e3a000d0          MOV      r0,#0xd0
001440  ebfffffe          BL       readByte
001444  e3500000          CMP      r0,#0
001448  0a000078          BEQ      |L1.5680|
;;;530         		if(readByte(MPU9250_ADDRESS, FIFO_R_W, &data[3]) == FALSE) return FALSE; // read data for averaging
00144c  e28a2003          ADD      r2,r10,#3
001450  e3a01072          MOV      r1,#0x72
001454  e3a000d0          MOV      r0,#0xd0
001458  ebfffffe          BL       readByte
00145c  e3500000          CMP      r0,#0
001460  0a000072          BEQ      |L1.5680|
;;;531        		if(readByte(MPU9250_ADDRESS, FIFO_R_W, &data[4]) == FALSE) return FALSE; // read data for averaging
001464  e28a2004          ADD      r2,r10,#4
001468  e3a01072          MOV      r1,#0x72
00146c  e3a000d0          MOV      r0,#0xd0
001470  ebfffffe          BL       readByte
001474  e3500000          CMP      r0,#0
001478  0a00006c          BEQ      |L1.5680|
;;;532        		if(readByte(MPU9250_ADDRESS, FIFO_R_W, &data[5]) == FALSE) return FALSE; // read data for averaging
00147c  e28a2005          ADD      r2,r10,#5
001480  e3a01072          MOV      r1,#0x72
001484  e3a000d0          MOV      r0,#0xd0
001488  ebfffffe          BL       readByte
00148c  e3500000          CMP      r0,#0
001490  0a000066          BEQ      |L1.5680|
;;;533    			accel_temp[0] = (short) (((short)data[0] << 8) | data[1]  );  // Form signed 16-bit integer for each sample in FIFO
001494  e5dd0001          LDRB     r0,[sp,#1]
001498  e5dd1000          LDRB     r1,[sp,#0]
;;;534        		accel_temp[1] = (short) (((short)data[2] << 8) | data[3]  );
;;;535        		accel_temp[2] = (short) (((short)data[4] << 8) | data[5]  );
00149c  e5dd3004          LDRB     r3,[sp,#4]
0014a0  e1800401          ORR      r0,r0,r1,LSL #8       ;533
0014a4  e1a02800          LSL      r2,r0,#16             ;533
0014a8  e5dd0003          LDRB     r0,[sp,#3]            ;534
0014ac  e5dd1002          LDRB     r1,[sp,#2]            ;534
0014b0  e1a02842          ASR      r2,r2,#16             ;533
0014b4  e1cd20b8          STRH     r2,[sp,#8]            ;533
0014b8  e1800401          ORR      r0,r0,r1,LSL #8       ;534
0014bc  e5dd1005          LDRB     r1,[sp,#5]
0014c0  e1a00800          LSL      r0,r0,#16             ;534
0014c4  e1a00840          ASR      r0,r0,#16             ;534
0014c8  e1811403          ORR      r1,r1,r3,LSL #8
0014cc  e1a01801          LSL      r1,r1,#16
0014d0  e1a01841          ASR      r1,r1,#16
0014d4  e1cd00ba          STRH     r0,[sp,#0xa]          ;534
0014d8  e1cd10bc          STRH     r1,[sp,#0xc]
;;;536        
;;;537        		calibrationDataACal.accelBias[0] += (long) accel_temp[0]; // Sum individual signed 16-bit biases to get accumulated signed 32-bit biases
0014dc  e5953004          LDR      r3,[r5,#4]  ; calibrationDataACal
0014e0  e0822003          ADD      r2,r2,r3
;;;538        		calibrationDataACal.accelBias[1] += (long) accel_temp[1];
0014e4  e5852004          STR      r2,[r5,#4]  ; calibrationDataACal
0014e8  e5952008          LDR      r2,[r5,#8]  ; calibrationDataACal
0014ec  e0800002          ADD      r0,r0,r2
;;;539        		calibrationDataACal.accelBias[2] += (long) accel_temp[2];
0014f0  e5850008          STR      r0,[r5,#8]  ; calibrationDataACal
0014f4  e595000c          LDR      r0,[r5,#0xc]  ; calibrationDataACal
0014f8  e0800001          ADD      r0,r0,r1
0014fc  e585000c          STR      r0,[r5,#0xc]  ; calibrationDataACal
001500  e2840001          ADD      r0,r4,#1              ;524
001504  e3c04801          BIC      r4,r0,#0x10000        ;524
001508  e2860001          ADD      r0,r6,#1              ;524
00150c  e3c06801          BIC      r6,r0,#0x10000        ;524
                  |L1.5392|
001510  e1540008          CMP      r4,r8                 ;524
001514  3affffba          BCC      |L1.5124|
;;;540        	}
;;;541            if(writeByte(MPU9250_ADDRESS, USER_CTRL, 0x0C) == FALSE) return FALSE;    // Reset FIFO and DMP
001518  e3a0200c          MOV      r2,#0xc
00151c  e3a01003          MOV      r1,#3
001520  e3a000d0          MOV      r0,#0xd0
001524  ebfffffe          BL       writeByte
001528  e3500000          CMP      r0,#0
00152c  0a00003f          BEQ      |L1.5680|
;;;542    		TIME_DELAY(15)
001530  e51f0cb8          LDR      r0,|L1.2176|
001534  ebfffffe          BL       initTimer
001538  e51f0cc0          LDR      r0,|L1.2176|
00153c  e3a0100f          MOV      r1,#0xf
001540  ebfffffe          BL       startTimer
                  |L1.5444|
001544  e51f0ccc          LDR      r0,|L1.2176|
001548  ebfffffe          BL       isTimerExpired
00154c  e3500000          CMP      r0,#0
001550  0afffffb          BEQ      |L1.5444|
001554  e2870001          ADD      r0,r7,#1              ;511
001558  e3c07801          BIC      r7,r0,#0x10000        ;511
00155c  e357000a          CMP      r7,#0xa               ;511
001560  3affff7d          BCC      |L1.4956|
;;;543    	}
;;;544    
;;;545    	calibrationDataACal.accelBias[0] /= (long) total_packets; // Normalize sums to get average count biases
001564  e5950004          LDR      r0,[r5,#4]  ; calibrationDataACal
001568  e1a01006          MOV      r1,r6
00156c  ebfffffe          BL       __aeabi_idivmod
;;;546    	calibrationDataACal.accelBias[1] /= (long) total_packets;
001570  e5850004          STR      r0,[r5,#4]  ; calibrationDataACal
001574  e5950008          LDR      r0,[r5,#8]  ; calibrationDataACal
001578  e1a01006          MOV      r1,r6
00157c  ebfffffe          BL       __aeabi_idivmod
;;;547    	calibrationDataACal.accelBias[2] /= (long) total_packets;
001580  e5850008          STR      r0,[r5,#8]  ; calibrationDataACal
001584  e595000c          LDR      r0,[r5,#0xc]  ; calibrationDataACal
001588  e1a01006          MOV      r1,r6
00158c  ebfffffe          BL       __aeabi_idivmod
001590  e585000c          STR      r0,[r5,#0xc]  ; calibrationDataACal
;;;548    
;;;549        // automatically determine the direction
;;;550        calibrationDataACal.boardOrientaton = BOARD_ORIENTATION_Z_AXIS_UP;
;;;551        for (ii = 0; ii < 3; ii++)
;;;552        {
;;;553            if(calibrationDataACal.accelBias[ii] * (2.0 / 32768.0) > 0.500)
001594  e59f7324          LDR      r7,|L1.6336|
001598  e3a00005          MOV      r0,#5                 ;550
00159c  e3a04000          MOV      r4,#0                 ;551
0015a0  e5c50010          STRB     r0,[r5,#0x10]         ;550  ; calibrationDataACal
                  |L1.5540|
0015a4  e0856104          ADD      r6,r5,r4,LSL #2
0015a8  e5960004          LDR      r0,[r6,#4]
0015ac  ebfffffe          BL       __aeabi_i2d
0015b0  e3e0200d          MVN      r2,#0xd
0015b4  ebfffffe          BL       __ARM_scalbn
0015b8  e3a02000          MOV      r2,#0
0015bc  e1a03007          MOV      r3,r7
0015c0  ebfffffe          BL       __aeabi_cdrcmple
;;;554            {
;;;555                calibrationDataACal.boardOrientaton = (BOARD_ORIENTATION)(ii + 3);
0015c4  32840003          ADDCC    r0,r4,#3
0015c8  35c50010          STRBCC   r0,[r5,#0x10]  ; calibrationDataACal
0015cc  3a00000c          BCC      |L1.5636|
;;;556                break;
;;;557            }
;;;558    
;;;559            if(calibrationDataACal.accelBias[ii] * (2.0 / 32768.0) < -0.500)
0015d0  e5960004          LDR      r0,[r6,#4]
0015d4  ebfffffe          BL       __aeabi_i2d
0015d8  e3e0200d          MVN      r2,#0xd
0015dc  ebfffffe          BL       __ARM_scalbn
0015e0  e59f32dc          LDR      r3,|L1.6340|
0015e4  e3a02000          MOV      r2,#0
0015e8  ebfffffe          BL       __aeabi_cdcmple
;;;560            {
;;;561                calibrationDataACal.boardOrientaton = (BOARD_ORIENTATION)ii;
0015ec  35c54010          STRBCC   r4,[r5,#0x10]  ; calibrationDataACal
0015f0  3a000003          BCC      |L1.5636|
0015f4  e2840001          ADD      r0,r4,#1              ;551
0015f8  e3c04801          BIC      r4,r0,#0x10000        ;551
0015fc  e3540003          CMP      r4,#3                 ;551
001600  3affffe7          BCC      |L1.5540|
                  |L1.5636|
;;;562                break;
;;;563            }
;;;564        }
;;;565        
;;;566        if(calibrationDataACal.accelBias[calibrationDataACal.boardOrientaton % 3] > 0L)
001604  e5d50010          LDRB     r0,[r5,#0x10]  ; calibrationDataACal
001608  e3a01003          MOV      r1,#3
00160c  ebfffffe          BL       __aeabi_uidivmod
001610  e0850101          ADD      r0,r5,r1,LSL #2
001614  e5901004          LDR      r1,[r0,#4]
001618  e3510000          CMP      r1,#0
;;;567        {
;;;568            calibrationDataACal.accelBias[calibrationDataACal.boardOrientaton % 3] -= (long) accelsensitivity;
00161c  c0411009          SUBGT    r1,r1,r9
;;;569        }  // Remove gravity from the z-axis accelerometer bias calculation
;;;570        else
;;;571        {
;;;572            calibrationDataACal.accelBias[calibrationDataACal.boardOrientaton % 3] += (long) accelsensitivity;
001620  d0811009          ADDLE    r1,r1,r9
001624  e5801004          STR      r1,[r0,#4]
;;;573        }
;;;574        
;;;575        returnValue = calibrationDataACalInit(FALSE);
001628  e3a00000          MOV      r0,#0
00162c  ebfffffe          BL       calibrationDataACalInit
                  |L1.5680|
001630  e28dd010          ADD      sp,sp,#0x10
001634  e8bd47f0          POP      {r4-r10,lr}
;;;576    	
;;;577    	return returnValue;
;;;578    }
001638  e12fff1e          BX       lr
;;;579    BOOL magcalMPU9250(float * dest1, float * dest2, MAGCAL_STATE magcalState) 
                          ENDP

                  magcalMPU9250 PROC
00163c  e92d4ffe          PUSH     {r1-r11,lr}
;;;580    {
;;;581    	float avg_rad;
;;;582    	
;;;583    	switch(magcalState)
;;;584    	{
;;;585    		case MAGCAL_STATE_INIT:
;;;586                mag_min[0] = 32767.0;
001640  e59f9280          LDR      r9,|L1.6344|
001644  e3520000          CMP      r2,#0                 ;583
001648  e1a04001          MOV      r4,r1                 ;580
00164c  e1a06000          MOV      r6,r0                 ;580
;;;587                mag_min[1] = 32767.0;
;;;588                mag_min[2] = 32767.0;
;;;589                mag_max[0] = -32767.0;
001650  e249500c          SUB      r5,r9,#0xc
001654  0a000002          BEQ      |L1.5732|
001658  e3520001          CMP      r2,#1                 ;583
00165c  0a00000b          BEQ      |L1.5776|
001660  ea00006b          B        |L1.6164|
                  |L1.5732|
001664  e59f0260          LDR      r0,|L1.6348|
;;;590                mag_max[1] = -32767.0;
;;;591                mag_max[2] = -327670.0;
;;;592    			write_Mag_Register(AK8963_CNTL2, 0x08);		
001668  e3a01008          MOV      r1,#8
00166c  e5890000          STR      r0,[r9,#0]            ;587  ; mag_min
001670  e5890004          STR      r0,[r9,#4]            ;588  ; mag_min
001674  e5890008          STR      r0,[r9,#8]            ;588  ; mag_min
001678  e1800a80          ORR      r0,r0,r0,LSL #21      ;589
00167c  e5850000          STR      r0,[r5,#0]            ;590  ; mag_max
001680  e5850004          STR      r0,[r5,#4]            ;590  ; mag_max
001684  e59f0244          LDR      r0,|L1.6352|
001688  e5850008          STR      r0,[r5,#8]  ; mag_max
;;;593    			break;
00168c  ea00005e          B        |L1.6156|
                  |L1.5776|
;;;594    			
;;;595    		case MAGCAL_STATE_FINISH:
;;;596    			// Get hard iron correction
;;;597    			mag_bias[0]  = (mag_max[0] + mag_min[0]) / 2.0;  // get average x mag bias
001690  e5990000          LDR      r0,[r9,#0]  ; mag_min
001694  e58d0008          STR      r0,[sp,#8]
001698  e595b000          LDR      r11,[r5,#0]  ; mag_max
00169c  e1a01000          MOV      r1,r0
0016a0  e1a0000b          MOV      r0,r11
0016a4  ebfffffe          BL       __aeabi_fadd
0016a8  e3e01000          MVN      r1,#0
0016ac  ebfffffe          BL       __ARM_scalbnf
0016b0  e59f721c          LDR      r7,|L1.6356|
0016b4  e1a08000          MOV      r8,r0
;;;598    			mag_bias[1]  = (mag_max[1] + mag_min[1]) / 2.0;  // get average y mag bias
0016b8  e5870000          STR      r0,[r7,#0]  ; mag_bias
0016bc  e5990004          LDR      r0,[r9,#4]  ; mag_min
0016c0  e58d0000          STR      r0,[sp,#0]
0016c4  e5950004          LDR      r0,[r5,#4]  ; mag_max
0016c8  e59d1000          LDR      r1,[sp,#0]
0016cc  e58d0004          STR      r0,[sp,#4]
0016d0  ebfffffe          BL       __aeabi_fadd
0016d4  e3e01000          MVN      r1,#0
0016d8  ebfffffe          BL       __ARM_scalbnf
;;;599    			mag_bias[2]  = (mag_max[2] + mag_min[2]) / 2.0;  // get average z mag bias
0016dc  e5870004          STR      r0,[r7,#4]  ; mag_bias
0016e0  e5999008          LDR      r9,[r9,#8]  ; mag_min
0016e4  e5955008          LDR      r5,[r5,#8]  ; mag_max
0016e8  e1a0a000          MOV      r10,r0                ;598
0016ec  e1a01009          MOV      r1,r9
0016f0  e1a00005          MOV      r0,r5
0016f4  ebfffffe          BL       __aeabi_fadd
0016f8  e3e01000          MVN      r1,#0
0016fc  ebfffffe          BL       __ARM_scalbnf
;;;600     
;;;601                dest1[0] = mag_bias[0];  // save mag biases in uT for main program
;;;602                dest1[1] = mag_bias[1];   
;;;603                dest1[2] = mag_bias[2];  
001700  e5870008          STR      r0,[r7,#8]  ; mag_bias
001704  e5860008          STR      r0,[r6,#8]
001708  e8860500          STM      r6,{r8,r10}
00170c  e59d1008          LDR      r1,[sp,#8]
001710  e1a0000b          MOV      r0,r11
;;;604    			// Get soft iron correction estimate
;;;605    
;;;606    			mag_scale[0]  = (mag_max[0] - mag_min[0]) / 2.0;  // get average x axis max chord length
001714  ebfffffe          BL       __aeabi_fsub
001718  e3e01000          MVN      r1,#0
00171c  ebfffffe          BL       __ARM_scalbnf
001720  e287600c          ADD      r6,r7,#0xc
001724  e5860000          STR      r0,[r6,#0]  ; mag_scale
001728  e1a08000          MOV      r8,r0
00172c  e59d0004          LDR      r0,[sp,#4]
001730  e59d1000          LDR      r1,[sp,#0]
;;;607    			mag_scale[1]  = (mag_max[1] - mag_min[1]) / 2.0;  // get average y axis max chord length
001734  ebfffffe          BL       __aeabi_fsub
001738  e3e01000          MVN      r1,#0
00173c  ebfffffe          BL       __ARM_scalbnf
001740  e1a07000          MOV      r7,r0
001744  e5860004          STR      r0,[r6,#4]  ; mag_scale
001748  e1a01009          MOV      r1,r9
00174c  e1a00005          MOV      r0,r5
;;;608    			mag_scale[2]  = (mag_max[2] - mag_min[2]) / 2.0;  // get average z axis max chord length
001750  ebfffffe          BL       __aeabi_fsub
001754  e3e01000          MVN      r1,#0
001758  ebfffffe          BL       __ARM_scalbnf
00175c  e1a05000          MOV      r5,r0
001760  e5860008          STR      r0,[r6,#8]  ; mag_scale
001764  e1a01007          MOV      r1,r7
001768  e1a00008          MOV      r0,r8
;;;609    
;;;610    			avg_rad = (mag_scale[0] + mag_scale[1] + mag_scale[2]) / 3.0;
00176c  ebfffffe          BL       __aeabi_fadd
001770  e1a01005          MOV      r1,r5
001774  ebfffffe          BL       __aeabi_fadd
001778  e59f1158          LDR      r1,|L1.6360|
00177c  ebfffffe          BL       __aeabi_fdiv
001780  e1a06000          MOV      r6,r0
;;;611    
;;;612    			dest2[0] = mag_scale[0] != 0 ? avg_rad / mag_scale[0] : 1.0;
001784  e1a00088          LSL      r0,r8,#1
001788  e1b00c20          LSRS     r0,r0,#24
00178c  059f1148          LDREQ    r1,|L1.6364|
001790  03a00000          MOVEQ    r0,#0
001794  0a000003          BEQ      |L1.6056|
001798  e1a01008          MOV      r1,r8
00179c  e1a00006          MOV      r0,r6
0017a0  ebfffffe          BL       __aeabi_fdiv
0017a4  ebfffffe          BL       __aeabi_f2d
                  |L1.6056|
0017a8  ebfffffe          BL       __aeabi_d2f
0017ac  e5840000          STR      r0,[r4,#0]
;;;613    			dest2[1] = mag_scale[1] != 0 ? avg_rad / mag_scale[1] : 1.0;
0017b0  e1a00087          LSL      r0,r7,#1
0017b4  e1b00c20          LSRS     r0,r0,#24
0017b8  059f111c          LDREQ    r1,|L1.6364|
0017bc  03a00000          MOVEQ    r0,#0
0017c0  0a000003          BEQ      |L1.6100|
0017c4  e1a01007          MOV      r1,r7
0017c8  e1a00006          MOV      r0,r6
0017cc  ebfffffe          BL       __aeabi_fdiv
0017d0  ebfffffe          BL       __aeabi_f2d
                  |L1.6100|
0017d4  ebfffffe          BL       __aeabi_d2f
0017d8  e5840004          STR      r0,[r4,#4]
;;;614    			dest2[2] = mag_scale[2] != 0 ? avg_rad / mag_scale[2] : 1.0;
0017dc  e1a00085          LSL      r0,r5,#1
0017e0  e1b00c20          LSRS     r0,r0,#24
0017e4  059f10f0          LDREQ    r1,|L1.6364|
0017e8  03a00000          MOVEQ    r0,#0
0017ec  0a000003          BEQ      |L1.6144|
0017f0  e1a01005          MOV      r1,r5
0017f4  e1a00006          MOV      r0,r6
0017f8  ebfffffe          BL       __aeabi_fdiv
0017fc  ebfffffe          BL       __aeabi_f2d
                  |L1.6144|
001800  ebfffffe          BL       __aeabi_d2f
;;;615    			write_Mag_Register(AK8963_CNTL2, 0x02);		
001804  e3a01002          MOV      r1,#2
001808  e5840008          STR      r0,[r4,#8]
                  |L1.6156|
00180c  e3a00031          MOV      r0,#0x31              ;592
001810  ebfffffe          BL       write_Mag_Register
                  |L1.6164|
;;;616    			break;
;;;617    			
;;;618    		default:;
;;;619    	}
;;;620    	
;;;621    	return TRUE;
001814  e8bd4ffe          POP      {r1-r11,lr}
001818  e3a00001          MOV      r0,#1
;;;622    }
00181c  e12fff1e          BX       lr
;;;623    
                          ENDP

                  getRate PROC
;;;624    float getRate(void)
001820  e51f0fac          LDR      r0,|L1.2172|
;;;625    {
;;;626    	float returnValue;
;;;627    	
;;;628    	returnValue = 1.0 / deltat;
001824  e5901010          LDR      r1,[r0,#0x10]  ; deltat
001828  e3a005fe          MOV      r0,#0x3f800000
00182c  eafffffe          B        __aeabi_fdiv
;;;629    
;;;630    	return returnValue;
;;;631    }
;;;632    
                          ENDP

                  getWhoAmI PROC
;;;692    
;;;693    BOOL getWhoAmI(BYTE *whoAmI9250, BYTE *whoamI8963)
001830  e92d4070          PUSH     {r4-r6,lr}
;;;694    {
001834  e1a05001          MOV      r5,r1
001838  e1a04000          MOV      r4,r0
;;;695    	// Read the WHO_AM_I register, this is a good test of communication
;;;696    	BANK(0)
00183c  e3a02000          MOV      r2,#0
001840  e3a0107f          MOV      r1,#0x7f
001844  e3a000d0          MOV      r0,#0xd0
001848  ebfffffe          BL       writeByte
;;;697    	if(readByte(MPU9250_ADDRESS, WHO_AM_I_MPU9250, whoAmI9250) == FALSE) return FALSE;
00184c  e1a02004          MOV      r2,r4
001850  e3a01000          MOV      r1,#0
001854  e3a000d0          MOV      r0,#0xd0
001858  ebfffffe          BL       readByte
00185c  e3500000          CMP      r0,#0
001860  0a000004          BEQ      |L1.6264|
;;;698    	if(read_Mag_Register(WHO_AM_I_AK8963, whoamI8963) == FALSE) return FALSE;
001864  e1a01005          MOV      r1,r5
001868  e3a00001          MOV      r0,#1
00186c  ebfffffe          BL       read_Mag_Register
001870  e3500000          CMP      r0,#0
;;;699    	
;;;700    	return TRUE;
001874  13a00001          MOVNE    r0,#1
                  |L1.6264|
001878  e8bd4070          POP      {r4-r6,lr}
;;;701    }
00187c  e12fff1e          BX       lr
;;;702    
                          ENDP

                  setMovingAveragePeriod PROC
;;;731    
;;;732    void setMovingAveragePeriod(float theMovingAveragePeriod)
001880  e59f1058          LDR      r1,|L1.6368|
;;;733    {
;;;734        MovingAveragePeriod = theMovingAveragePeriod;
001884  e5810014          STR      r0,[r1,#0x14]  ; MovingAveragePeriod
;;;735    }
001888  e12fff1e          BX       lr
;;;736    
                          ENDP

                  setAccelerometerFilter PROC
;;;737    void setAccelerometerFilter(float theAccelerometerFilter)
00188c  e92d4010          PUSH     {r4,lr}
;;;738    {
;;;739        AccelerometerFilter = theAccelerometerFilter;
001890  ebfffffe          BL       __aeabi_f2uiz
001894  e59f1044          LDR      r1,|L1.6368|
001898  e5c10002          STRB     r0,[r1,#2]  ; AccelerometerFilter
;;;740    }
00189c  e8bd4010          POP      {r4,lr}
0018a0  e12fff1e          BX       lr
;;;741    float getMovingAveragePeriod(void)
                          ENDP

                  getMovingAveragePeriod PROC
0018a4  e59f0034          LDR      r0,|L1.6368|
;;;742    {
;;;743        return MovingAveragePeriod;
0018a8  e5900014          LDR      r0,[r0,#0x14]  ; MovingAveragePeriod
;;;744    }
0018ac  e12fff1e          BX       lr
;;;745    
                          ENDP

                  getAccelerometerFilter PROC
;;;746    float getAccelerometerFilter(void)
0018b0  e59f0028          LDR      r0,|L1.6368|
;;;747    {
;;;748        return AccelerometerFilter;
0018b4  e5d00002          LDRB     r0,[r0,#2]  ; AccelerometerFilter
0018b8  eafffffe          B        __aeabi_ui2f
;;;749    }
;;;750    
                          ENDP

                  |L1.6332|
                          DCD      ||.data||+0x34
                  |L1.6336|
                          DCD      0x3fe00000
                  |L1.6340|
                          DCD      0xbfe00000
                  |L1.6344|
                          DCD      ||area_number.4||+0x680
                  |L1.6348|
                          DCD      0x46fffe00
                  |L1.6352|
                          DCD      0xc89ffec0
                  |L1.6356|
                          DCD      ||area_number.4||+0x65c
                  |L1.6360|
                          DCD      0x40400000
                  |L1.6364|
                          DCD      0x3ff00000
                  |L1.6368|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  SelfTest
                          %        24

                          AREA ||area_number.4||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.4||, ||.bss||
                  calibrationDataACal
                          %        84
                  calibrationDataMCal
                          %        104
                  MxResultsFiltered
                          %        480
                  MyResultsFiltered
                          %        480
                  MzResultsFiltered
                          %        480
                  mag_bias
                          %        12
                  mag_scale
                          %        12
                  mag_max
                          %        12
                  mag_min
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  OrientationMatrix
000000  00000000          DCFS     0x00000000 ; 0
000004  00000000          DCFS     0x00000000 ; 0
000008  bf800000          DCFS     0xbf800000 ; -1
00000c  00000000          DCFS     0x00000000 ; 0
000010  3f800000          DCFS     0x3f800000 ; 1
000014  00000000          DCFS     0x00000000 ; 0
000018  bf800000          DCFS     0xbf800000 ; -1
00001c  00000000          DCFS     0x00000000 ; 0
000020  00000000          DCFS     0x00000000 ; 0
000024  bf800000          DCFS     0xbf800000 ; -1
000028  00000000          DCFS     0x00000000 ; 0
00002c  00000000          DCFS     0x00000000 ; 0
000030  00000000          DCFS     0x00000000 ; 0
000034  00000000          DCFS     0x00000000 ; 0
000038  bf800000          DCFS     0xbf800000 ; -1
00003c  00000000          DCFS     0x00000000 ; 0
000040  bf800000          DCFS     0xbf800000 ; -1
000044  00000000          DCFS     0x00000000 ; 0
000048  bf800000          DCFS     0xbf800000 ; -1
00004c  00000000          DCFS     0x00000000 ; 0
000050  00000000          DCFS     0x00000000 ; 0
000054  00000000          DCFS     0x00000000 ; 0
000058  3f800000          DCFS     0x3f800000 ; 1
00005c  00000000          DCFS     0x00000000 ; 0
000060  00000000          DCFS     0x00000000 ; 0
000064  00000000          DCFS     0x00000000 ; 0
000068  bf800000          DCFS     0xbf800000 ; -1
00006c  00000000          DCFS     0x00000000 ; 0
000070  00000000          DCFS     0x00000000 ; 0
000074  bf800000          DCFS     0xbf800000 ; -1
000078  00000000          DCFS     0x00000000 ; 0
00007c  bf800000          DCFS     0xbf800000 ; -1
000080  00000000          DCFS     0x00000000 ; 0
000084  3f800000          DCFS     0x3f800000 ; 1
000088  00000000          DCFS     0x00000000 ; 0
00008c  00000000          DCFS     0x00000000 ; 0
000090  3f800000          DCFS     0x3f800000 ; 1
000094  00000000          DCFS     0x00000000 ; 0
000098  00000000          DCFS     0x00000000 ; 0
00009c  00000000          DCFS     0x00000000 ; 0
0000a0  00000000          DCFS     0x00000000 ; 0
0000a4  bf800000          DCFS     0xbf800000 ; -1
0000a8  00000000          DCFS     0x00000000 ; 0
0000ac  3f800000          DCFS     0x3f800000 ; 1
0000b0  00000000          DCFS     0x00000000 ; 0
0000b4  3f800000          DCFS     0x3f800000 ; 1
0000b8  00000000          DCFS     0x00000000 ; 0
0000bc  00000000          DCFS     0x00000000 ; 0
0000c0  00000000          DCFS     0x00000000 ; 0
0000c4  3f800000          DCFS     0x3f800000 ; 1
0000c8  00000000          DCFS     0x00000000 ; 0
0000cc  00000000          DCFS     0x00000000 ; 0
0000d0  00000000          DCFS     0x00000000 ; 0
0000d4  3f800000          DCFS     0x3f800000 ; 1
                  magOrientationMatrix
0000d8  00000000          DCFS     0x00000000 ; 0
0000dc  00000000          DCFS     0x00000000 ; 0
0000e0  bf800000          DCFS     0xbf800000 ; -1
0000e4  00000000          DCFS     0x00000000 ; 0
0000e8  3f800000          DCFS     0x3f800000 ; 1
0000ec  00000000          DCFS     0x00000000 ; 0
0000f0  bf800000          DCFS     0xbf800000 ; -1
0000f4  00000000          DCFS     0x00000000 ; 0
0000f8  00000000          DCFS     0x00000000 ; 0
0000fc  bf800000          DCFS     0xbf800000 ; -1
000100  00000000          DCFS     0x00000000 ; 0
000104  00000000          DCFS     0x00000000 ; 0
000108  00000000          DCFS     0x00000000 ; 0
00010c  00000000          DCFS     0x00000000 ; 0
000110  bf800000          DCFS     0xbf800000 ; -1
000114  00000000          DCFS     0x00000000 ; 0
000118  bf800000          DCFS     0xbf800000 ; -1
00011c  00000000          DCFS     0x00000000 ; 0
000120  bf800000          DCFS     0xbf800000 ; -1
000124  00000000          DCFS     0x00000000 ; 0
000128  00000000          DCFS     0x00000000 ; 0
00012c  00000000          DCFS     0x00000000 ; 0
000130  3f800000          DCFS     0x3f800000 ; 1
000134  00000000          DCFS     0x00000000 ; 0
000138  00000000          DCFS     0x00000000 ; 0
00013c  00000000          DCFS     0x00000000 ; 0
000140  bf800000          DCFS     0xbf800000 ; -1
000144  00000000          DCFS     0x00000000 ; 0
000148  00000000          DCFS     0x00000000 ; 0
00014c  bf800000          DCFS     0xbf800000 ; -1
000150  00000000          DCFS     0x00000000 ; 0
000154  bf800000          DCFS     0xbf800000 ; -1
000158  00000000          DCFS     0x00000000 ; 0
00015c  3f800000          DCFS     0x3f800000 ; 1
000160  00000000          DCFS     0x00000000 ; 0
000164  00000000          DCFS     0x00000000 ; 0
000168  3f800000          DCFS     0x3f800000 ; 1
00016c  00000000          DCFS     0x00000000 ; 0
000170  00000000          DCFS     0x00000000 ; 0
000174  00000000          DCFS     0x00000000 ; 0
000178  00000000          DCFS     0x00000000 ; 0
00017c  bf800000          DCFS     0xbf800000 ; -1
000180  00000000          DCFS     0x00000000 ; 0
000184  3f800000          DCFS     0x3f800000 ; 1
000188  00000000          DCFS     0x00000000 ; 0
00018c  3f800000          DCFS     0x3f800000 ; 1
000190  00000000          DCFS     0x00000000 ; 0
000194  00000000          DCFS     0x00000000 ; 0
000198  00000000          DCFS     0x00000000 ; 0
00019c  3f800000          DCFS     0x3f800000 ; 1
0001a0  00000000          DCFS     0x00000000 ; 0
0001a4  00000000          DCFS     0x00000000 ; 0
0001a8  00000000          DCFS     0x00000000 ; 0
0001ac  3f800000          DCFS     0x3f800000 ; 1

                          AREA ||.data||, DATA, ALIGN=2

                  Ascale
000000  00                DCB      0x00
                  Mscale
000001  01                DCB      0x01
                  AccelerometerFilter
000002  06                DCB      0x06
                  inCalibration
000003  00                DCB      0x00
                  dataAvailable
000004  00                DCB      0x00
                  intType
000005  00                DCB      0x00
                  tempCount
000006  0000              DCB      0x00,0x00
                  lastUpdate
                          DCD      0x00000000
                  Now
                          DCD      0x00000000
                  deltat
000010  00000000          DCFS     0x00000000 ; 0
                  MovingAveragePeriod
000014  42700000          DCFS     0x42700000 ; 60
                  aRes
                          DCD      0x00000000
                  mRes
                          DCD      0x00000000
                  ||ax||
                          DCD      0x00000000
                  ||ay||
                          DCD      0x00000000
                  ||az||
                          DCD      0x00000000
                  ||mx||
                          DCD      0x00000000
                  ||my||
                          DCD      0x00000000
                  ||mz||
                          DCD      0x00000000
                  temperature
                          DCD      0x00000000
                  magCount
                          DCD      0x00000000
000040  0000              DCB      0x00,0x00
                  accelCount
000042  0000              DCB      0x00,0x00
                          DCD      0x00000000
                  delayTimer
                          %        8
